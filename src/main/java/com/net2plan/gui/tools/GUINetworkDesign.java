/*******************************************************************************
 * Copyright (c) 2015 Pablo Pavon Mariño.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v2.1
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/lgpl.html
 * <p>
 * Contributors:
 * Pablo Pavon Mariño - initial API and implementation
 ******************************************************************************/


package com.net2plan.gui.tools;

import com.net2plan.gui.utils.ParameterValueDescriptionPanel;
import com.net2plan.gui.utils.RunnableSelector;
import com.net2plan.gui.utils.ThreadExecutionController;
import com.net2plan.interfaces.networkDesign.Configuration;
import com.net2plan.interfaces.networkDesign.IAlgorithm;
import com.net2plan.interfaces.networkDesign.NetPlan;
import com.net2plan.internal.ErrorHandling;
import com.net2plan.internal.SystemUtils;
import com.net2plan.utils.ClassLoaderUtils;
import com.net2plan.utils.Triple;
import net.miginfocom.swing.MigLayout;

import javax.swing.*;
import javax.swing.border.LineBorder;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import java.io.Closeable;
import java.io.File;
import java.util.List;
import java.util.Map;

/**
 * Targeted to evaluate the network designs generated by built-in or user-defined
 * static planning algorithms, deciding on aspects such as the network topology,
 * the traffic routing, link capacities, protection routes and so on. Algorithms
 * based on constrained optimization formulations (i.e. ILPs) can be fast-prototyped
 * using the open-source Java Optimization Modeler library, to interface
 * to a number of external solvers such as GPLK, CPLEX or IPOPT.
 *
 * @author Pablo Pavon-Marino, Jose-Luis Izquierdo-Zaragoza
 * @since 0.2.0
 */
public class GUINetworkDesign extends IGUINetworkViewer {
    private final static String TITLE = "Offline network design";

    private JPanel executionPane;
    private JTextArea txt_netPlanLog;
    private ThreadExecutionController algorithmController;
    private RunnableSelector algorithmSelector;
    private long start;

    /**
     * Default constructor.
     *
     * @since 0.2.0
     */
    public GUINetworkDesign() {
        this(TITLE);
    }

    /**
     * Constructor that allows set a title for the tool in the top section of the panel.
     *
     * @param title Title of the tool (null or empty means no title)
     * @since 0.2.0
     */
    public GUINetworkDesign(String title) {
        super(title);
    }

    @Override
    protected boolean allowLoadTrafficDemands() {
        return true;
    }

    @Override
    public void configure(JPanel contentPane) {
        super.configure(contentPane);

        File ALGORITHMS_DIRECTORY = new File(CURRENT_DIR + SystemUtils.getDirectorySeparator() + "workspace");
        ALGORITHMS_DIRECTORY = ALGORITHMS_DIRECTORY.isDirectory() ? ALGORITHMS_DIRECTORY : CURRENT_DIR;

        ParameterValueDescriptionPanel algorithmParameters = new ParameterValueDescriptionPanel();
        algorithmSelector = new RunnableSelector("Algorithm", null, IAlgorithm.class, ALGORITHMS_DIRECTORY, algorithmParameters);
        algorithmController = new ThreadExecutionController(this);
        JPanel pnl_buttons = new JPanel(new MigLayout("", "[center, grow]", "[]"));

        final JButton btn_solve = new JButton("Execute");
        pnl_buttons.add(btn_solve);
        btn_solve.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                algorithmController.execute();
            }
        });

        addKeyCombinationAction("Execute algorithm", new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent e) {
                showTab(1);
                btn_solve.doClick();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_E, KeyEvent.CTRL_DOWN_MASK));


        executionPane = new JPanel();
        executionPane.setLayout(new MigLayout("insets 0 0 0 0", "[grow]", "[grow]"));
        executionPane.add(algorithmSelector, "grow");
        executionPane.add(pnl_buttons, "dock south");

        addTab("Algorithm execution", executionPane, 1);
    }

    @Override
    protected JPanel configureLeftBottomPanel() {
        txt_netPlanLog = new JTextArea();
        txt_netPlanLog.setFont(new JLabel().getFont());
        JPanel pane = new JPanel(new MigLayout("fill, insets 0 0 0 0"));
        pane.setBorder(BorderFactory.createTitledBorder(new LineBorder(Color.BLACK), "Warnings"));
        pane.add(new JScrollPane(txt_netPlanLog), "grow");
        return pane;
    }

    @Override
    public Object execute(ThreadExecutionController controller) {
        if (controller == algorithmController) {
            start = System.nanoTime();
            final Triple<File, String, Class> algorithm = algorithmSelector.getRunnable();
            final Map<String, String> algorithmParameters = algorithmSelector.getRunnableParameters();
            final Map<String, String> net2planParameters = Configuration.getNet2PlanOptions();
            NetPlan netPlan = getDesign().copy();
            IAlgorithm instance = ClassLoaderUtils.getInstance(algorithm.getFirst(), algorithm.getSecond(), IAlgorithm.class);
//			System.out.println ("BEFORE EXECUTING");
            String out = instance.executeAlgorithm(netPlan, algorithmParameters, net2planParameters);
//			System.out.println ("AFTER EXECUTING");
            try {
                ((Closeable) instance.getClass().getClassLoader()).close();
            } catch (Throwable e) {
            }
            netPlan.setNetworkLayerDefault(netPlan.getNetworkLayer((int) 0));
            getDesign().assignFrom(netPlan);
            return out;
        } else {
            return super.execute(controller);
        }
    }

    @Override
    public void executionFailed(ThreadExecutionController controller) {
        if (controller == algorithmController) ErrorHandling.showErrorDialog("Error executing algorithm");
        else super.executionFailed(controller);
    }

    @Override
    public void executionFinished(ThreadExecutionController controller, Object out) {
        if (controller == algorithmController) {
            try {
                double execTime = (System.nanoTime() - start) / 1e9;
                topologyPanel.updateLayerChooser();
                getTopologyPanel().getCanvas().zoomAll();

                String outMessage = String.format("Algorithm executed successfully%nExecution time: %.3g s%nExit message: %s", execTime, out);
                JOptionPane.showMessageDialog(null, outMessage, "Solve design", JOptionPane.PLAIN_MESSAGE);
                showNetPlanView();
            } catch (Throwable ex) {
                ErrorHandling.addErrorOrException(ex, GUINetworkDesign.class);
                ErrorHandling.showErrorDialog("Error executing algorithm");
            }
        } else {
            super.executionFinished(controller, out);
        }
    }

    @Override
    public String getDescription() {
        return getName();
    }

    @Override
    public KeyStroke getKeyStroke() {
        return KeyStroke.getKeyStroke(KeyEvent.VK_1, InputEvent.ALT_DOWN_MASK);
    }

    @Override
    public String getMenu() {
        return "Tools|" + TITLE;
    }

    @Override
    public String getName() {
        return TITLE + " (GUI)";
    }

    @Override
    public List<Triple<String, String, String>> getParameters() {
        return null;
    }

    @Override
    public int getPriority() {
        return Integer.MAX_VALUE;
    }

    @Override
    public boolean isEditable() {
        return true;
    }

    @Override
    protected void reset_internal() {
        super.reset_internal();
        algorithmSelector.reset();
    }

    @Override
    protected void updateLog(String text) {
        txt_netPlanLog.setText(null);
        txt_netPlanLog.setText(text);
        txt_netPlanLog.setCaretPosition(0);
    }
}
