/*******************************************************************************
 * Copyright (c) 2015 Pablo Pavon Mariño.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v2.1
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/lgpl.html
 * <p>
 * Contributors:
 * Pablo Pavon Mariño - initial API and implementation
 ******************************************************************************/


package com.net2plan.gui.tools;

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.Point2D;
import java.util.*;
import java.util.List;

import javax.swing.*;
import javax.swing.border.LineBorder;
import javax.swing.table.TableModel;

import com.net2plan.gui.utils.INetworkCallback;
import com.net2plan.gui.utils.ProportionalResizeJSplitPaneListener;
import com.net2plan.gui.utils.offlineExecPane.OfflineExecutionPanel;
import com.net2plan.gui.utils.onlineSimulationPane.OnlineSimulationPane;
import com.net2plan.gui.utils.topologyPane.TopologyPanel;
import com.net2plan.gui.utils.topologyPane.jung.JUNGCanvas;
import com.net2plan.gui.utils.topologyPane.jung.topologyDistribution.CircularDistribution;
import com.net2plan.gui.utils.topologyPane.jung.topologyDistribution.ITopologyDistribution;
import com.net2plan.gui.utils.topologyPane.mapControl.osm.state.OSMMapStateBuilder;
import com.net2plan.gui.utils.viewEditTopolTables.ViewEditTopologyTablesPane;
import com.net2plan.gui.utils.viewEditTopolTables.specificTables.AdvancedJTableNetworkElement;
import com.net2plan.gui.utils.viewEditTopolTables.specificTables.AdvancedJTable_node;
import com.net2plan.gui.utils.viewReportsPane.ViewReportPane;
import com.net2plan.gui.utils.viewEditWindows.WindowController;
import com.net2plan.gui.utils.viewEditWindows.utils.WindowUtils;
import com.net2plan.interfaces.networkDesign.Configuration;
import com.net2plan.interfaces.networkDesign.Demand;
import com.net2plan.interfaces.networkDesign.Link;
import com.net2plan.interfaces.networkDesign.MulticastDemand;
import com.net2plan.interfaces.networkDesign.MulticastTree;
import com.net2plan.interfaces.networkDesign.Net2PlanException;
import com.net2plan.interfaces.networkDesign.NetPlan;
import com.net2plan.interfaces.networkDesign.NetworkLayer;
import com.net2plan.interfaces.networkDesign.Node;
import com.net2plan.interfaces.networkDesign.ProtectionSegment;
import com.net2plan.interfaces.networkDesign.Route;
import com.net2plan.internal.Constants.NetworkElementType;
import com.net2plan.internal.ErrorHandling;
import com.net2plan.internal.plugins.IGUIModule;
import com.net2plan.internal.sim.SimCore.SimState;
import com.net2plan.libraries.NetworkPerformanceMetrics;
import com.net2plan.utils.Pair;
import com.net2plan.utils.StringUtils;
import com.net2plan.utils.TopologyMap;
import com.net2plan.utils.Triple;

import cern.colt.matrix.tdouble.DoubleMatrix1D;
import net.miginfocom.swing.MigLayout;

/**
 * Targeted to evaluate the network designs generated by built-in or user-defined
 * static planning algorithms, deciding on aspects such as the network topology,
 * the traffic routing, link capacities, protection routes and so on. Algorithms
 * based on constrained optimization formulations (i.e. ILPs) can be fast-prototyped
 * using the open-source Java Optimization Modeler library, to interface
 * to a number of external solvers such as GPLK, CPLEX or IPOPT.
 */
public class GUINetworkDesign extends IGUIModule implements INetworkCallback
{
    public static Color COLOR_INITIALNODE = new Color(0, 153, 51);
    public static Color COLOR_ENDNODE = new Color(0, 162, 215);

    private final static String TITLE = "Offline network design & Online network simulation";

    private TopologyPanel topologyPanel;

    private JTextArea txt_netPlanLog;

    private ViewEditTopologyTablesPane viewEditTopTables;
    private ViewReportPane reportPane;
    private OfflineExecutionPanel executionPane;
    private OnlineSimulationPane onlineSimulationPane;

    /**
     * Reference to the popup menu in the topology panel.
     *
     * @since 0.3.0
     */
    private JPanel leftPane;
    private NetPlan currentNetPlan;

    private TopologyMap initialTopologySetting;
    private ITopologyDistribution circularTopologySetting;

    /**
     * Default constructor.
     *
     * @since 0.2.0
     */
    public GUINetworkDesign()
    {
        this(TITLE);
    }

    /**
     * Constructor that allows set a title for the tool in the top section of the panel.
     *
     * @param title Title of the tool (null or empty means no title)
     * @since 0.2.0
     */
    public GUINetworkDesign(String title)
    {
        super(title);
    }

//    public boolean allowLoadTrafficDemands()
//    {
//        return true;
//    }

    @Override
    public void configure(JPanel contentPane)
    {
        topologyPanel = new TopologyPanel(this, JUNGCanvas.class);

        // Running OSM state machine.
        new OSMMapStateBuilder.SingletonBuilder(topologyPanel, this).build();

        // Map distributions
        circularTopologySetting = new CircularDistribution();

        leftPane = new JPanel(new BorderLayout());
        JPanel logSection = configureLeftBottomPanel();
        if (logSection == null)
        {
            leftPane.add(topologyPanel, BorderLayout.CENTER);
        } else
        {
            JSplitPane splitPaneTopology = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
            splitPaneTopology.setTopComponent(topologyPanel);
            splitPaneTopology.setBottomComponent(logSection);
            splitPaneTopology.setResizeWeight(0.8);
            splitPaneTopology.addPropertyChangeListener(new ProportionalResizeJSplitPaneListener());
            splitPaneTopology.setBorder(new LineBorder(contentPane.getBackground()));
            splitPaneTopology.setOneTouchExpandable(true);
            splitPaneTopology.setDividerSize(7);
            leftPane.add(splitPaneTopology, BorderLayout.CENTER);
        }
        contentPane.add(leftPane, "grow");

        viewEditTopTables = new ViewEditTopologyTablesPane(GUINetworkDesign.this, new BorderLayout());

        reportPane = new ViewReportPane(GUINetworkDesign.this, JSplitPane.VERTICAL_SPLIT);

        loadDesign(new NetPlan());

        onlineSimulationPane = new OnlineSimulationPane(this);
        executionPane = new OfflineExecutionPanel(this);

        // Closing windows
        WindowUtils.clearFloatingWindows();

        final JTabbedPane tabPane = new JTabbedPane();
        tabPane.add(WindowController.WindowToTab.getTabName(WindowController.WindowToTab.network), viewEditTopTables);
        tabPane.add(WindowController.WindowToTab.getTabName(WindowController.WindowToTab.offline), executionPane);
        tabPane.add(WindowController.WindowToTab.getTabName(WindowController.WindowToTab.online), onlineSimulationPane);
        tabPane.add(WindowController.WindowToTab.getTabName(WindowController.WindowToTab.report), reportPane);

        // Installing customized mouse listener
        MouseListener[] ml = tabPane.getListeners(MouseListener.class);

        for (int i = 0; i < ml.length; i++)
        {
            tabPane.removeMouseListener(ml[i]);
        }

        // Left click works as usual, right click brings up a pop-up menu.
        tabPane.addMouseListener(new MouseAdapter()
        {
            public void mousePressed(MouseEvent e)
            {
                JTabbedPane tabPane = (JTabbedPane) e.getSource();

                int tabIndex = tabPane.getUI().tabForCoordinate(tabPane, e.getX(), e.getY());

                if (tabIndex >= 0 && tabPane.isEnabledAt(tabIndex))
                {
                    if (tabIndex == tabPane.getSelectedIndex())
                    {
                        if (tabPane.isRequestFocusEnabled())
                        {
                            tabPane.requestFocus();

                            tabPane.repaint(tabPane.getUI().getTabBounds(tabPane, tabIndex));
                        }
                    } else
                    {
                        tabPane.setSelectedIndex(tabIndex);
                    }

                    if (!tabPane.isEnabled() || SwingUtilities.isRightMouseButton(e))
                    {
                        final JPopupMenu popupMenu = new JPopupMenu();

                        final JMenuItem popWindow = new JMenuItem("Pop window out");
                        popWindow.addActionListener(e1 ->
                        {
                            final int selectedIndex = tabPane.getSelectedIndex();
                            final String tabName = tabPane.getTitleAt(selectedIndex);
                            final JComponent selectedComponent = (JComponent) tabPane.getSelectedComponent();

                            // Pops up the selected tab.
                            final WindowController.WindowToTab windowToTab = WindowController.WindowToTab.parseString(tabName);

                            switch (windowToTab)
                            {
                                case offline:
                                    WindowController.buildOfflineWindow(selectedComponent);
                                    WindowController.showOfflineWindow();
                                    break;
                                case online:
                                    WindowController.buildOnlineWindow(selectedComponent);
                                    WindowController.showOnlineWindow();
                                    break;
                                case report:
                                    WindowController.buildReportWindow(selectedComponent);
                                    WindowController.showReportWindow();
                                    break;
                                default:
                                    return;
                            }

                            tabPane.setSelectedIndex(0);
                        });

                        // Disabling the pop up button for the network state tab.
                        if (WindowController.WindowToTab.parseString(tabPane.getTitleAt(tabPane.getSelectedIndex())) == WindowController.WindowToTab.network)
                        {
                            popWindow.setEnabled(false);
                        }

                        popupMenu.add(popWindow);

                        popupMenu.show(e.getComponent(), e.getX(), e.getY());
                    }
                }
            }
        });

        // Building windows
        WindowController.buildControlWindow(tabPane);

        addAllKeyCombinationActions();
    }


    private JPanel configureLeftBottomPanel()
    {
        txt_netPlanLog = new JTextArea();
        txt_netPlanLog.setFont(new JLabel().getFont());
        JPanel pane = new JPanel(new MigLayout("fill, insets 0 0 0 0"));
        pane.setBorder(BorderFactory.createTitledBorder(new LineBorder(Color.BLACK), "Warnings"));
        pane.add(new JScrollPane(txt_netPlanLog), "grow");
        return pane;
    }

    @Override
    public Map<NetworkElementType, AdvancedJTableNetworkElement> getTables()
    {
        return viewEditTopTables.currentTables();
    }

    @Override
    public String getDescription()
    {
        return getName();
    }

    @Override
    public KeyStroke getKeyStroke()
    {
        return KeyStroke.getKeyStroke(KeyEvent.VK_1, InputEvent.ALT_DOWN_MASK);
    }

    @Override
    public String getMenu()
    {
        return "Tools|" + TITLE;
    }

    @Override
    public String getName()
    {
        return TITLE + " (GUI)";
    }

    @Override
    public List<Triple<String, String, String>> getParameters()
    {
        return null;
    }

    @Override
    public int getPriority()
    {
        return Integer.MAX_VALUE;
    }


    private void updateLog(String text)
    {
        txt_netPlanLog.setText(null);
        txt_netPlanLog.setText(text);
        txt_netPlanLog.setCaretPosition(0);
    }

    @Override
    public long addLink(long originNode, long destinationNode)
    {
        long layer = getDesign().getNetworkLayerDefault().getId();
        return addLink(layer, originNode, destinationNode);
    }

    @Override
    public long addLink(long layer, long originNode, long destinationNode)
    {
        if (!isEditable()) throw new UnsupportedOperationException("Not supported");

        NetPlan netPlan = getDesign();
        Link link = netPlan.addLink(netPlan.getNodeFromId(originNode), netPlan.getNodeFromId(destinationNode), 0, 0, 200000, null, netPlan.getNetworkLayerFromId(layer));

        if (layer == netPlan.getNetworkLayerDefault().getId())
        {
            topologyPanel.getCanvas().addLink(link);
            topologyPanel.getCanvas().refresh();
        }

        updateNetPlanView();
        return link.getId();
    }

    @Override
    public Pair<Long, Long> addLinkBidirectional(long originNode, long destinationNode)
    {
        return addLinkBidirectional(getDesign().getNetworkLayerDefault().getId(), originNode, destinationNode);
    }

    @Override
    public Pair<Long, Long> addLinkBidirectional(long layer, long originNode, long destinationNode)
    {
        if (!isEditable()) throw new UnsupportedOperationException("Not supported");

        NetPlan netPlan = getDesign();
        Pair<Link, Link> links = netPlan.addLinkBidirectional(netPlan.getNodeFromId(originNode), netPlan.getNodeFromId(destinationNode), 0, 0, 200000, null, netPlan.getNetworkLayerFromId(layer));
        if (layer == netPlan.getNetworkLayerDefault().getId())
        {
            topologyPanel.getCanvas().addLink(links.getFirst());
            topologyPanel.getCanvas().addLink(links.getSecond());
            topologyPanel.getCanvas().refresh();
        }

        updateNetPlanView();
        return Pair.of(links.getFirst().getId(), links.getSecond().getId());
    }

    @Override
    public void addNode(Point2D pos)
    {
        if (!isEditable()) throw new UnsupportedOperationException("Not supported");

        NetPlan netPlan = getDesign();
        long nodeId = netPlan.getNetworkElementNextId();

        OSMMapStateBuilder.getSingleton().addNode(netPlan, "Node " + nodeId, pos);
        updateNetPlanView();
    }

    @Override
    public NetPlan getDesign()
    {
        if (inOnlineSimulationMode()) return onlineSimulationPane.getSimKernel().getCurrentNetPlan();
        else return currentNetPlan;
    }

    @Override
    public NetPlan getInitialDesign()
    {
        if (inOnlineSimulationMode()) return onlineSimulationPane.getSimKernel().getInitialNetPlan();
        else return null;
    }

    @Override
    public List<JComponent> getCanvasActions(Point2D pos)
    {
        List<JComponent> actions = new LinkedList<>();

        if (isEditable())
        {
            JMenuItem addNode = new JMenuItem(new AddNodeAction("Add node here", pos));
            actions.add(addNode);

            actions.add(new JPopupMenu.Separator());

            JMenuItem restoreTopology = new JMenuItem("Restore topology to original layout");
            restoreTopology.setToolTipText("Restores all nodes to their original position when the topology was loaded, leaves them in place if they were not in the original topology.");
            restoreTopology.addActionListener(e ->
            {
                for (Node node : currentNetPlan.getNodes())
                {
                    // This is supposed to be done with the OSM state manager, but that does not exactly do what is required here.
                    moveNode(node.getId(), initialTopologySetting.getNodeLocation(node));
                }

                topologyPanel.zoomAll();
            });

            actions.add(restoreTopology);

            JMenu topologySettingMenu = new JMenu("Change topology layout");

            JMenuItem circularSetting = new JMenuItem("Circular");
            circularSetting.addActionListener(e ->
            {
                final Map<Long, Point2D> nodePosition = circularTopologySetting.getNodeDistribution(currentNetPlan.getNodes());

                for (Node node : currentNetPlan.getNodes())
                {
                    OSMMapStateBuilder.getSingleton().moveNode(node, nodePosition.get(node.getId()));
                }

                topologyPanel.zoomAll();
            });

            topologySettingMenu.add(circularSetting);

            actions.add(topologySettingMenu);
        }

        return actions;
    }

    @Override
    public List<JComponent> getLinkActions(long link, Point2D pos)
    {
        List<JComponent> actions = new LinkedList<JComponent>();

        if (isEditable())
            actions.add(new JMenuItem(new RemoveLinkAction("Remove link", link)));

        return actions;
    }

    @Override
    public List<JComponent> getNodeActions(long nodeId, Point2D pos)
    {
        List<JComponent> actions = new LinkedList<JComponent>();

        if (isEditable())
        {
            actions.add(new JMenuItem(new RemoveNodeAction("Remove node", nodeId)));

            NetPlan netPlan = getDesign();
            Node node = netPlan.getNodeFromId(nodeId);
            if (netPlan.getNumberOfNodes() > 1)
            {
                actions.add(new JPopupMenu.Separator());
                JMenu unidirectionalMenu = new JMenu("Create unidirectional link");
                JMenu bidirectionalMenu = new JMenu("Create bidirectional link");

                String nodeName = node.getName() == null ? "" : node.getName();
                String nodeString = Long.toString(nodeId) + (nodeName.isEmpty() ? "" : " (" + nodeName + ")");

                long layer = netPlan.getNetworkLayerDefault().getId();
                for (Node auxNode : netPlan.getNodes())
                {
                    if (auxNode.getId() == nodeId) continue;

                    String auxNodeName = auxNode.getName() == null ? "" : auxNode.getName();
                    String auxNodeString = Long.toString(auxNode.getId()) + (auxNodeName.isEmpty() ? "" : " (" + auxNodeName + ")");

                    AbstractAction unidirectionalAction = new AddLinkAction(nodeString + " => " + auxNodeString, layer, nodeId, auxNode.getId());
                    unidirectionalMenu.add(unidirectionalAction);

                    AbstractAction bidirectionalAction = new AddLinkBidirectionalAction(nodeString + " <=> " + auxNodeString, layer, nodeId, auxNode.getId());
                    bidirectionalMenu.add(bidirectionalAction);
                }

                actions.add(unidirectionalMenu);
                actions.add(bidirectionalMenu);
            }
        }

        return actions;
    }

    @Override
    public boolean isEditable()
    {
        if (onlineSimulationPane == null) return true;
        final SimState simState = onlineSimulationPane.getSimKernel().getSimCore().getSimulationState();
        if (simState == SimState.PAUSED || simState == SimState.RUNNING || simState == SimState.STEP)
            return false;
        else return true;
    }

    @Override
    public void layerChanged(long layer)
    {
    }

    @Override
    public void loadDesign(NetPlan netPlan)
    {
        viewEditTopTables.resetTables();
        netPlan.checkCachesConsistency();
        if (onlineSimulationPane != null) onlineSimulationPane.getSimKernel().setNetPlan(netPlan);
        currentNetPlan = netPlan;
        netPlan.checkCachesConsistency();

        // Saving original topology structure
        initialTopologySetting = new TopologyMap();
        currentNetPlan.getNodes().stream().forEach(node -> initialTopologySetting.addNodeLocation(node.getId(), node.getXYPositionMap()));

        topologyPanel.updateLayerChooser();
        topologyPanel.getCanvas().zoomAll();
        resetView();
    }

    @Override
    public void loadTrafficDemands(NetPlan demands)
    {
        if (!demands.hasDemands() && !demands.hasMulticastDemands())
            throw new Net2PlanException("Selected file doesn't contain a demand set");

        NetPlan netPlan = getDesign();
        if (netPlan.hasDemands() || netPlan.hasMulticastDemands())
        {
            int result = JOptionPane.showConfirmDialog(null, "Current network structure contains a demand set. Overwrite?", "Loading demand set", JOptionPane.YES_NO_OPTION);
            if (result != JOptionPane.YES_OPTION) return;
        }

        NetPlan aux_netPlan = netPlan.copy();
        try
        {
            netPlan.removeAllDemands();
            for (Demand demand : demands.getDemands())
                netPlan.addDemand(netPlan.getNode(demand.getIngressNode().getIndex()), netPlan.getNode(demand.getEgressNode().getIndex()), demand.getOfferedTraffic(), demand.getAttributes());

            netPlan.removeAllMulticastDemands();
            for (MulticastDemand demand : demands.getMulticastDemands())
            {
                Set<Node> egressNodesThisNetPlan = new HashSet<Node>();
                for (Node n : demand.getEgressNodes()) egressNodesThisNetPlan.add(netPlan.getNode(n.getIndex()));
                netPlan.addMulticastDemand(netPlan.getNode(demand.getIngressNode().getIndex()), egressNodesThisNetPlan, demand.getOfferedTraffic(), demand.getAttributes());
            }

            updateNetPlanView();
        } catch (Throwable ex)
        {
            getDesign().assignFrom(aux_netPlan);
            throw new RuntimeException(ex);
        }
    }

    @Override
    public void moveNode(long node, Point2D pos)
    {
        if (!isEditable()) throw new UnsupportedOperationException("Not supported");

        TableModel nodeTableModel = viewEditTopTables.getNetPlanViewTable().get(NetworkElementType.NODE).getModel();
        int numRows = nodeTableModel.getRowCount();
        for (int row = 0; row < numRows; row++)
        {
            if ((long) nodeTableModel.getValueAt(row, 0) == node)
            {
                nodeTableModel.setValueAt(pos.getX(), row, AdvancedJTable_node.COLUMN_XCOORD);
                nodeTableModel.setValueAt(pos.getY(), row, AdvancedJTable_node.COLUMN_YCOORD);
            }
        }
    }

    @Override
    public void removeLink(long link)
    {
        if (!isEditable()) throw new UnsupportedOperationException("Not supported");

        NetPlan netPlan = getDesign();
        if (netPlan.getLinkFromId(link).getLayer().equals(getDesign().getNetworkLayerDefault()))
        {
            topologyPanel.getCanvas().removeLink(netPlan.getLinkFromId(link));
            topologyPanel.getCanvas().refresh();
        }
        netPlan.getLinkFromId(link).remove();

        updateNetPlanView();
    }

    @Override
    public void removeNode(long node)
    {
        if (!isEditable()) throw new UnsupportedOperationException("Not supported");

        NetPlan netPlan = getDesign();
        topologyPanel.getCanvas().removeNode(netPlan.getNodeFromId(node));
        topologyPanel.getCanvas().refresh();
        netPlan.getNodeFromId(node).remove();
        updateNetPlanView();
    }

    @Override
    public void reset()
    {
        try
        {
            if (!askForReset()) return;

            if (inOnlineSimulationMode())
            {
                switch (onlineSimulationPane.getSimKernel().getSimCore().getSimulationState())
                {
                    case NOT_STARTED:
                    case STOPPED:
                        break;
                    default:
                        onlineSimulationPane.getSimKernel().getSimCore().setSimulationState(SimState.STOPPED);
                        break;
                }
                onlineSimulationPane.getSimKernel().reset();
                loadDesign(onlineSimulationPane.getSimKernel().getCurrentNetPlan());
            } else
            {
                loadDesign(new NetPlan());
                //algorithmSelector.reset();
                executionPane.reset();
            }
//            reportSelector.reset();
//            reportContainer.removeAll();
        } catch (Throwable ex)
        {
            ErrorHandling.addErrorOrException(ex, GUINetworkDesign.class);
            ErrorHandling.showErrorDialog("Unable to reset");
        }
    }

    @Override
    public void resetView()
    {
        topologyPanel.getCanvas().resetPickedAndUserDefinedColorState();
        viewEditTopTables.getNetPlanViewTable().get(NetworkElementType.DEMAND).clearSelection();
        viewEditTopTables.getNetPlanViewTable().get(NetworkElementType.MULTICAST_DEMAND).clearSelection();
        viewEditTopTables.getNetPlanViewTable().get(NetworkElementType.FORWARDING_RULE).clearSelection();
        viewEditTopTables.getNetPlanViewTable().get(NetworkElementType.LINK).clearSelection();
        viewEditTopTables.getNetPlanViewTable().get(NetworkElementType.NODE).clearSelection();
        viewEditTopTables.getNetPlanViewTable().get(NetworkElementType.PROTECTION_SEGMENT).clearSelection();
        viewEditTopTables.getNetPlanViewTable().get(NetworkElementType.MULTICAST_TREE).clearSelection();
        viewEditTopTables.getNetPlanViewTable().get(NetworkElementType.SRG).clearSelection();
    }

    public void showDemand(long demandId)
    {
        NetPlan netPlan = getDesign();
        NetworkLayer layer = netPlan.getDemandFromId(demandId).getLayer();
        selectNetPlanViewItem(layer.getId(), NetworkElementType.DEMAND, demandId);
        Demand demand = netPlan.getDemandFromId(demandId);

        Map<Node, Color> nodes = new HashMap<Node, Color>();
        nodes.put(demand.getIngressNode(), COLOR_INITIALNODE);
        nodes.put(demand.getEgressNode(), COLOR_ENDNODE);
        Map<Link, Pair<Color, Boolean>> links = new HashMap<Link, Pair<Color, Boolean>>();

        DoubleMatrix1D x_e = netPlan.getMatrixDemand2LinkTrafficCarried(layer).viewRow(demand.getIndex()).copy();
        for (int e = 0; e < x_e.size(); e++)
            if (x_e.get(e) > 0)
            {
                links.put(netPlan.getLink(e, layer), Pair.of(Color.BLUE, false));
            }
        topologyPanel.getCanvas().showAndPickNodesAndLinks(nodes, links);
        topologyPanel.getCanvas().refresh();
    }

    @Override
    public void showMulticastDemand(long demandId)
    {
        NetPlan netPlan = getDesign();
        MulticastDemand demand = netPlan.getMulticastDemandFromId(demandId);
        NetworkLayer layer = demand.getLayer();
        selectNetPlanViewItem(layer.getId(), NetworkElementType.MULTICAST_DEMAND, demandId);

        Map<Node, Color> nodes = new HashMap<Node, Color>();
        nodes.put(demand.getIngressNode(), COLOR_INITIALNODE);
        for (Node n : demand.getEgressNodes()) nodes.put(n, COLOR_ENDNODE);
        Map<Link, Pair<Color, Boolean>> links = new HashMap<Link, Pair<Color, Boolean>>();

        DoubleMatrix1D x_e = netPlan.getMatrixMulticastDemand2LinkTrafficCarried(layer).viewRow(demand.getIndex()).copy();
        for (int e = 0; e < x_e.size(); e++)
            if (x_e.get(e) > 0) links.put(netPlan.getLinkFromId(e), Pair.of(Color.BLUE, false));
        topologyPanel.getCanvas().showAndPickNodesAndLinks(nodes, links);
        topologyPanel.getCanvas().refresh();
    }

    @Override
    public void showForwardingRule(Pair<Integer, Integer> demandLink)
    {
        NetPlan netPlan = getDesign();
        Demand demand = netPlan.getDemand(demandLink.getFirst());
        Link link = netPlan.getLink(demandLink.getSecond());
        NetworkLayer layer = demand.getLayer();
        selectNetPlanViewItem(layer.getId(), NetworkElementType.FORWARDING_RULE, Pair.of(demand.getIndex(), link.getIndex()));

        Map<Node, Color> nodes = new HashMap<Node, Color>();
        nodes.put(demand.getIngressNode(), COLOR_INITIALNODE);
        nodes.put(demand.getEgressNode(), COLOR_ENDNODE);
        Map<Link, Pair<Color, Boolean>> links = new HashMap<Link, Pair<Color, Boolean>>();
        links.put(link, Pair.of(Color.BLUE, false));
        topologyPanel.getCanvas().showAndPickNodesAndLinks(nodes, links);
        topologyPanel.getCanvas().refresh();
    }

    @Override
    public void showLink(long linkId)
    {
        NetPlan netPlan = getDesign();
        Link link = netPlan.getLinkFromId(linkId);
        selectNetPlanViewItem(link.getLayer().getId(), NetworkElementType.LINK, linkId);

        topologyPanel.getCanvas().showNode(link.getOriginNode(), COLOR_INITIALNODE);
        topologyPanel.getCanvas().showNode(link.getDestinationNode(), COLOR_ENDNODE);

        topologyPanel.getCanvas().showLink(link, link.isUp() ? Color.BLUE : Color.RED, false);
        topologyPanel.getCanvas().refresh();
    }

    @Override
    public void showNode(long nodeId)
    {
        selectNetPlanViewItem(getDesign().getNetworkLayerDefault().getId(), NetworkElementType.NODE, nodeId);

        topologyPanel.getCanvas().showNode(getDesign().getNodeFromId(nodeId), Color.BLUE);
        topologyPanel.getCanvas().refresh();
    }

    @Override
    public void showProtectionSegment(long segmentId)
    {
        NetPlan netPlan = getDesign();
        ProtectionSegment segment = netPlan.getProtectionSegmentFromId(segmentId);
        selectNetPlanViewItem(segment.getLayer().getId(), NetworkElementType.PROTECTION_SEGMENT, segmentId);
        Map<Link, Pair<Color, Boolean>> res = new HashMap<Link, Pair<Color, Boolean>>();
        for (Link e : segment.getSeqLinks()) res.put(e, Pair.of(Color.YELLOW, false));
        topologyPanel.getCanvas().showAndPickNodesAndLinks(null, res);
        topologyPanel.getCanvas().refresh();
    }

    @Override
    public void showRoute(long routeId) // yellow segment link not used, orange segment link used, blue not segment link used. The same for initial state, in dashed
    {
        NetPlan netPlan = getDesign();
        Route route = netPlan.getRouteFromId(routeId);
        NetworkLayer layer = route.getLayer();
        selectNetPlanViewItem(layer.getId(), NetworkElementType.ROUTE, routeId);

        NetPlan initialState = getInitialDesign();

        Map<Node, Color> selectedNodes = new HashMap<>();
        Map<Link, Pair<Color, Boolean>> coloredLinks = new HashMap<Link, Pair<Color, Boolean>>();
        if (inOnlineSimulationMode() && viewEditTopTables.isInitialNetPlanShown())
        {
            Route initialRoute = initialState.getRouteFromId(route.getId());
            if (initialRoute != null)
            {
                for (ProtectionSegment s : initialRoute.getPotentialBackupProtectionSegments())
                    for (Link e : s.getSeqLinks())
                        if (netPlan.getLinkFromId(e.getId()) != null)
                        {
                            Link selectedLink = netPlan.getLinkFromId(e.getId());
                            selectedNodes.put(selectedLink.getOriginNode(), Color.YELLOW);
                            selectedNodes.put(selectedLink.getDestinationNode(), Color.YELLOW);
                            coloredLinks.put(selectedLink, Pair.of(Color.YELLOW, true));
                        }
                for (Link linkOrSegment : initialRoute.getSeqLinksAndProtectionSegments())
                    if (linkOrSegment instanceof ProtectionSegment)
                    {
                        for (Link e : ((ProtectionSegment) linkOrSegment).getSeqLinks())
                            if (netPlan.getLinkFromId(e.getId()) != null)
                            {
                                Link selectedLink = netPlan.getLinkFromId(e.getId());
                                selectedNodes.put(selectedLink.getOriginNode(), Color.ORANGE);
                                selectedNodes.put(selectedLink.getDestinationNode(), Color.ORANGE);
                                coloredLinks.put(selectedLink, Pair.of(Color.ORANGE, true));
                            }
                    } else if (netPlan.getLinkFromId(linkOrSegment.getId()) != null)
                    {
                        Link selectedLink = netPlan.getLinkFromId(linkOrSegment.getId());
                        selectedNodes.put(selectedLink.getOriginNode(), Color.BLUE);
                        selectedNodes.put(selectedLink.getDestinationNode(), Color.BLUE);
                        coloredLinks.put(selectedLink, Pair.of(Color.BLUE, true));
                    }
            }
        }
        for (ProtectionSegment s : route.getPotentialBackupProtectionSegments())
            for (Link e : s.getSeqLinks())
            {
                selectedNodes.put(e.getOriginNode(), Color.YELLOW);
                selectedNodes.put(e.getDestinationNode(), Color.YELLOW);
                coloredLinks.put(e, Pair.of(Color.YELLOW, false));
            }
        for (Link linkOrSegment : route.getSeqLinksAndProtectionSegments())
            if (linkOrSegment instanceof ProtectionSegment)
            {
                for (Link e : ((ProtectionSegment) linkOrSegment).getSeqLinks())
                {
                    selectedNodes.put(e.getOriginNode(), Color.ORANGE);
                    selectedNodes.put(e.getDestinationNode(), Color.ORANGE);
                    coloredLinks.put(netPlan.getLinkFromId(e.getId()), Pair.of(Color.ORANGE, false));
                }
            } else
            {
                selectedNodes.put(linkOrSegment.getOriginNode(), Color.BLUE);
                selectedNodes.put(linkOrSegment.getDestinationNode(), Color.BLUE);
                coloredLinks.put(linkOrSegment, Pair.of(Color.BLUE, false));
            }

        topologyPanel.getCanvas().showAndPickNodesAndLinks(selectedNodes, coloredLinks);
        topologyPanel.getCanvas().refresh();
    }

    @Override
    public void showMulticastTree(long treeId)
    {
        NetPlan netPlan = getDesign();
        MulticastTree tree = netPlan.getMulticastTreeFromId(treeId);
        NetworkLayer layer = tree.getLayer();
        selectNetPlanViewItem(layer.getId(), NetworkElementType.MULTICAST_TREE, treeId);

        NetPlan currentState = getDesign();
        NetPlan initialState = getInitialDesign();
        Map<Node, Color> coloredNodes = new HashMap<Node, Color>();
        Map<Link, Pair<Color, Boolean>> coloredLinks = new HashMap<Link, Pair<Color, Boolean>>();
        if (inOnlineSimulationMode() && viewEditTopTables.isInitialNetPlanShown())
        {
            MulticastTree initialTree = initialState.getMulticastTreeFromId(treeId);
            if (initialTree != null)
                for (Link e : initialTree.getLinkSet())
                    if (currentState.getLinkFromId(e.getId()) != null)
                        coloredLinks.put(currentState.getLinkFromId(e.getId()), Pair.of(Color.BLUE, true));
        }
        for (Link e : tree.getLinkSet()) coloredLinks.put(e, Pair.of(Color.BLUE, false));
        coloredNodes.put(tree.getIngressNode(), COLOR_INITIALNODE);
        for (Node n : tree.getEgressNodes()) coloredNodes.put(n, COLOR_ENDNODE);
        topologyPanel.getCanvas().showAndPickNodesAndLinks(coloredNodes, coloredLinks);
        topologyPanel.getCanvas().refresh();
    }

    @Override
    public void showSRG(long srg)
    {
        showSRG(getDesign().getNetworkLayerDefault().getId(), srg);
    }

    @Override
    public void showSRG(long layer, long srg)
    {
        NetPlan netPlan = getDesign();
        selectNetPlanViewItem(layer, NetworkElementType.SRG, srg);

        Set<Node> nodeIds_thisSRG = netPlan.getSRGFromId(srg).getNodes();
        Set<Link> linkIds_thisSRG_thisLayer = netPlan.getSRGFromId(srg).getLinks(netPlan.getNetworkLayerFromId(layer));
        Map<Node, Color> nodeColors = new HashMap<Node, Color>();
        Map<Link, Pair<Color, Boolean>> linkColors = new HashMap<Link, Pair<Color, Boolean>>();
        for (Node n : nodeIds_thisSRG) nodeColors.put(n, Color.ORANGE);
        for (Link e : linkIds_thisSRG_thisLayer) linkColors.put(e, Pair.of(Color.ORANGE, false));

        topologyPanel.getCanvas().showAndPickNodesAndLinks(nodeColors, linkColors);
        topologyPanel.getCanvas().refresh();
    }

    private class RemoveLinkAction extends AbstractAction
    {
        private final long link;

        public RemoveLinkAction(String name, long link)
        {
            super(name);
            this.link = link;
        }

        @Override
        public void actionPerformed(ActionEvent e)
        {
            removeLink(link);
        }
    }

    private class RemoveNodeAction extends AbstractAction
    {
        private final long node;

        public RemoveNodeAction(String name, long node)
        {
            super(name);
            this.node = node;
        }

        @Override
        public void actionPerformed(ActionEvent e)
        {
            removeNode(node);
        }
    }

    private class AddNodeAction extends AbstractAction
    {
        private final Point2D pos;

        public AddNodeAction(String name, Point2D pos)
        {
            super(name);
            this.pos = pos;
        }

        @Override
        public void actionPerformed(ActionEvent e)
        {
            addNode(pos);
        }
    }

    private class AddLinkAction extends AbstractAction
    {
        private final long layer;
        private final long originNode;
        private final long destinationNode;

        public AddLinkAction(String name, long layer, long originNode, long destinationNode)
        {
            super(name);
            this.layer = layer;
            this.originNode = originNode;
            this.destinationNode = destinationNode;
        }

        @Override
        public void actionPerformed(ActionEvent e)
        {
            addLink(layer, originNode, destinationNode);
        }
    }

    private class AddLinkBidirectionalAction extends AbstractAction
    {
        private final long layer;
        private final long originNode;
        private final long destinationNode;

        public AddLinkBidirectionalAction(String name, long layer, long originNode, long destinationNode)
        {
            super(name);
            this.layer = layer;
            this.originNode = originNode;
            this.destinationNode = destinationNode;
        }

        @Override
        public void actionPerformed(ActionEvent e)
        {
            addLinkBidirectional(layer, originNode, destinationNode);
        }

    }

    /**
     * Asks user to confirm plugin reset.
     *
     * @return {@code true} if user confirms to reset the plugin, or {@code false} otherwise
     * @since 0.2.3
     */
    private static boolean askForReset()
    {
        int result = JOptionPane.showConfirmDialog(null, "Are you sure you want to reset? This will remove all unsaved data", "Reset", JOptionPane.YES_NO_OPTION);

        return result == JOptionPane.YES_OPTION;
    }

    /**
     * Shows the tab corresponding associated to a network element.
     *
     * @param layer  Layer identifier
     * @param type   Network element type
     * @param itemId Item identifier (if null, it will just show the tab)
     * @since 0.3.0
     */
    private void selectNetPlanViewItem(long layer, NetworkElementType type, Object itemId)
    {
        topologyPanel.selectLayer(layer);
        viewEditTopTables.selectViewItem(type, itemId);
    }

    /**
     * Indicates whether or not the initial {@code NetPlan} object is stored to be
     * compared with the current one (i.e. after some simulation steps).
     *
     * @return {@code true} if the initial {@code NetPlan} object is stored. Otherwise, {@code false}.
     * @since 0.3.0
     */
    public boolean inOnlineSimulationMode()
    {
        if (onlineSimulationPane == null) return false;
        final SimState simState = onlineSimulationPane.getSimKernel().getSimCore().getSimulationState();
        if (simState == SimState.PAUSED || simState == SimState.RUNNING || simState == SimState.STEP)
            return true;
        else return false;
    }

    @Override
    public synchronized void updateNetPlanView()
    {
        updateWarnings();
        viewEditTopTables.updateView();
    }

    @Override
    public void updateWarnings()
    {
        Map<String, String> net2planParameters = Configuration.getNet2PlanOptions();
        List<String> warnings = NetworkPerformanceMetrics.checkNetworkState(getDesign(), net2planParameters);
        String warningMsg = warnings.isEmpty() ? "Design is successfully completed!" : StringUtils.join(warnings, StringUtils.getLineSeparator());
        updateLog(warningMsg);
    }

    /**
     * Shows the {@code NetPlan} view, moving to the corresponding tab.
     *
     * @since 0.3.0
     */
    @Override
    public final void showNetPlanView()
    {
        viewEditTopTables.getNetPlanView().setSelectedIndex(0);
    }

    @Override
    public TopologyPanel getTopologyPanel()
    {
        return topologyPanel;
    }

    private void addAllKeyCombinationActions()
    {
        addKeyCombinationAction("Resets the tool", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                reset();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_R, InputEvent.CTRL_DOWN_MASK));

        addKeyCombinationAction("Outputs current design to console", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                System.out.println(getDesign().toString());
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_F11, InputEvent.CTRL_DOWN_MASK));

        /* FROM THE OFFLINE ALGORITHM EXECUTION */

        addKeyCombinationAction("Execute algorithm", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                executionPane.doClickInExecutionButton();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_E, KeyEvent.CTRL_DOWN_MASK));

        /* From the TOPOLOGY PANEL */
        addKeyCombinationAction("Load design", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                topologyPanel.loadDesign();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_O, InputEvent.CTRL_DOWN_MASK));

        addKeyCombinationAction("Save design", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                topologyPanel.saveDesign();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_S, InputEvent.CTRL_DOWN_MASK));

        addKeyCombinationAction("Zoom in", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                topologyPanel.zoomIn();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_ADD, InputEvent.CTRL_DOWN_MASK), KeyStroke.getKeyStroke(KeyEvent.VK_PLUS, InputEvent.CTRL_DOWN_MASK));

        addKeyCombinationAction("Zoom out", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                topologyPanel.zoomOut();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_SUBTRACT, InputEvent.CTRL_DOWN_MASK), KeyStroke.getKeyStroke(KeyEvent.VK_MINUS, InputEvent.CTRL_DOWN_MASK));

        addKeyCombinationAction("Zoom all", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                topologyPanel.zoomAll();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_MULTIPLY, InputEvent.CTRL_DOWN_MASK));

        addKeyCombinationAction("Take snapshot", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                topologyPanel.takeSnapshot();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_F12, InputEvent.CTRL_DOWN_MASK));

        addKeyCombinationAction("Load traffic demands", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                topologyPanel.loadTrafficDemands();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_T, InputEvent.CTRL_DOWN_MASK));
        
        /* FROM REPORT */
        addKeyCombinationAction("Close selected report", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                int tab = reportPane.getReportContainer().getSelectedIndex();
                if (tab == -1) return;
                reportPane.getReportContainer().remove(tab);
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_W, InputEvent.CTRL_DOWN_MASK));

        addKeyCombinationAction("Close all reports", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                reportPane.getReportContainer().removeAll();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_W, InputEvent.CTRL_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK));


        /* Online simulation */
        addKeyCombinationAction("Run simulation", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                try
                {
                    if (onlineSimulationPane.isRunButtonEnabled()) onlineSimulationPane.runSimulation(false);
                } catch (Net2PlanException ex)
                {
                    if (ErrorHandling.isDebugEnabled())
                        ErrorHandling.addErrorOrException(ex, OnlineSimulationPane.class);
                    ErrorHandling.showErrorDialog(ex.getMessage(), "Error executing simulation");
                } catch (Throwable ex)
                {
                    ErrorHandling.addErrorOrException(ex, OnlineSimulationPane.class);
                    ErrorHandling.showErrorDialog("An error happened");
                }

            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_U, InputEvent.CTRL_DOWN_MASK));

        // Windows
        addKeyCombinationAction("Show control window", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e) {
                WindowController.showControlWindow();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_1, ActionEvent.ALT_MASK + ActionEvent.SHIFT_MASK));
    }
}
