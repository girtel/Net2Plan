// TODO: Hacer los pick de demanda, ruta etc, cogiendo lo que hice the multilayer. Hasta que compile todo salvo OSM
// TODO: Con Jorge hacer lo de OSM
// TODO: Repaso de llamadas a metodos llaman a ICallback, uno a uno, depurando los updates.
// TODO: Mirar dentro de los metodos updates: hay que tocar tambien el layer chooser y quiza mas cosas visibles
// TODO: Pruebas y pruebas...

/*******************************************************************************


 * 
 * 
 * Copyright (c) 2015 Pablo Pavon Mariño.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v2.1
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/lgpl.html
 * <p>
 * Contributors:
 * Pablo Pavon Mariño - initial API and implementation
 ******************************************************************************/


package com.net2plan.gui.tools;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.geom.Point2D;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.swing.AbstractAction;
import javax.swing.BorderFactory;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JTabbedPane;
import javax.swing.JTextArea;
import javax.swing.KeyStroke;
import javax.swing.SwingUtilities;
import javax.swing.border.LineBorder;

import com.net2plan.gui.utils.ClassAwareTableModel;
import com.net2plan.gui.utils.IVisualizationControllerCallback;
import com.net2plan.gui.utils.ProportionalResizeJSplitPaneListener;
import com.net2plan.gui.utils.offlineExecPane.OfflineExecutionPanel;
import com.net2plan.gui.utils.onlineSimulationPane.OnlineSimulationPane;
import com.net2plan.gui.utils.topologyPane.GUILink;
import com.net2plan.gui.utils.topologyPane.GUINode;
import com.net2plan.gui.utils.topologyPane.TopologyPanel;
import com.net2plan.gui.utils.topologyPane.VisualizationState;
import com.net2plan.gui.utils.topologyPane.jung.JUNGCanvas;
import com.net2plan.gui.utils.topologyPane.jung.topologyDistribution.CircularDistribution;
import com.net2plan.gui.utils.topologyPane.jung.topologyDistribution.ITopologyDistribution;
import com.net2plan.gui.utils.topologyPane.mapControl.osm.state.OSMMapStateBuilder;
import com.net2plan.gui.utils.viewEditTopolTables.ViewEditTopologyTablesPane;
import com.net2plan.gui.utils.viewEditTopolTables.specificTables.AdvancedJTable_node;
import com.net2plan.gui.utils.viewEditWindows.WindowController;
import com.net2plan.gui.utils.viewEditWindows.utils.WindowUtils;
import com.net2plan.gui.utils.viewReportsPane.ViewReportPane;
import com.net2plan.interfaces.networkDesign.Configuration;
import com.net2plan.interfaces.networkDesign.Demand;
import com.net2plan.interfaces.networkDesign.Link;
import com.net2plan.interfaces.networkDesign.MulticastDemand;
import com.net2plan.interfaces.networkDesign.MulticastTree;
import com.net2plan.interfaces.networkDesign.Net2PlanException;
import com.net2plan.interfaces.networkDesign.NetPlan;
import com.net2plan.interfaces.networkDesign.NetworkElement;
import com.net2plan.interfaces.networkDesign.NetworkLayer;
import com.net2plan.interfaces.networkDesign.Node;
import com.net2plan.interfaces.networkDesign.Resource;
import com.net2plan.interfaces.networkDesign.Route;
import com.net2plan.interfaces.networkDesign.SharedRiskGroup;
import com.net2plan.internal.Constants.NetworkElementType;
import com.net2plan.internal.ErrorHandling;
import com.net2plan.internal.plugins.IGUIModule;
import com.net2plan.internal.sim.SimCore.SimState;
import com.net2plan.libraries.NetworkPerformanceMetrics;
import com.net2plan.utils.Pair;
import com.net2plan.utils.StringUtils;
import com.net2plan.utils.TopologyMap;
import com.net2plan.utils.Triple;

import cern.colt.matrix.tdouble.DoubleMatrix1D;
import net.miginfocom.swing.MigLayout;

/**
 * Targeted to evaluate the network designs generated by built-in or user-defined
 * static planning algorithms, deciding on aspects such as the network topology,
 * the traffic routing, link capacities, protection routes and so on. Algorithms
 * based on constrained optimization formulations (i.e. ILPs) can be fast-prototyped
 * using the open-source Java Optimization Modeler library, to interface
 * to a number of external solvers such as GPLK, CPLEX or IPOPT.
 */
public class GUINetworkDesign extends IGUIModule implements IVisualizationControllerCallback
{
    public static Color COLOR_INITIALNODE = new Color(0, 153, 51);
    public static Color COLOR_ENDNODE = new Color(0, 162, 215);

    private final static String TITLE = "Offline network design & Online network simulation";

    private TopologyPanel topologyPanel;

    private JTextArea txt_netPlanLog;

    private ViewEditTopologyTablesPane viewEditTopTables;
    private ViewReportPane reportPane;
    private OfflineExecutionPanel executionPane;
    private OnlineSimulationPane onlineSimulationPane;
	private VisualizationState vs;

    /**
     * Reference to the popup menu in the topology panel.
     *
     * @since 0.3.0
     */
    private JPanel leftPane;
    private NetPlan currentNetPlan;

//    private TopologyMap initialTopologySetting;
    private ITopologyDistribution circularTopologySetting;

    /**
     * Default constructor.
     *
     * @since 0.2.0
     */
    public GUINetworkDesign()
    {
        this(TITLE);
    }

    /**
     * Constructor that allows set a title for the tool in the top section of the panel.
     *
     * @param title Title of the tool (null or empty means no title)
     * @since 0.2.0
     */
    public GUINetworkDesign(String title)
    {
        super(title);
    }

//    public boolean allowLoadTrafficDemands()
//    {
//        return true;
//    }

    @Override
    public void configure(JPanel contentPane)
    {
    	this.currentNetPlan = new NetPlan ();
    	this.vs = new VisualizationState(currentNetPlan);

    	topologyPanel = new TopologyPanel(this, JUNGCanvas.class);

        // Running OSM state machine.
        new OSMMapStateBuilder.SingletonBuilder(topologyPanel, this).build();

        // Map distributions
        circularTopologySetting = new CircularDistribution();

        leftPane = new JPanel(new BorderLayout());
        JPanel logSection = configureLeftBottomPanel();
        if (logSection == null)
        {
            leftPane.add(topologyPanel, BorderLayout.CENTER);
        } else
        {
            JSplitPane splitPaneTopology = new JSplitPane(JSplitPane.VERTICAL_SPLIT);
            splitPaneTopology.setTopComponent(topologyPanel);
            splitPaneTopology.setBottomComponent(logSection);
            splitPaneTopology.setResizeWeight(0.8);
            splitPaneTopology.addPropertyChangeListener(new ProportionalResizeJSplitPaneListener());
            splitPaneTopology.setBorder(new LineBorder(contentPane.getBackground()));
            splitPaneTopology.setOneTouchExpandable(true);
            splitPaneTopology.setDividerSize(7);
            leftPane.add(splitPaneTopology, BorderLayout.CENTER);
        }
        contentPane.add(leftPane, "grow");

        viewEditTopTables = new ViewEditTopologyTablesPane(GUINetworkDesign.this, new BorderLayout());

        reportPane = new ViewReportPane(GUINetworkDesign.this, JSplitPane.VERTICAL_SPLIT);

        loadDesignDoNotUpdateVisualization(currentNetPlan);
        updateVisualizationAfterNewTopology();
        
        onlineSimulationPane = new OnlineSimulationPane(this);
        executionPane = new OfflineExecutionPanel(this);

        // Closing windows
        WindowUtils.clearFloatingWindows();

        final JTabbedPane tabPane = new JTabbedPane();
        tabPane.add(WindowController.WindowToTab.getTabName(WindowController.WindowToTab.network), viewEditTopTables);
        tabPane.add(WindowController.WindowToTab.getTabName(WindowController.WindowToTab.offline), executionPane);
        tabPane.add(WindowController.WindowToTab.getTabName(WindowController.WindowToTab.online), onlineSimulationPane);
        tabPane.add(WindowController.WindowToTab.getTabName(WindowController.WindowToTab.report), reportPane);

        // Installing customized mouse listener
        MouseListener[] ml = tabPane.getListeners(MouseListener.class);

        for (int i = 0; i < ml.length; i++)
        {
            tabPane.removeMouseListener(ml[i]);
        }

        // Left click works as usual, right click brings up a pop-up menu.
        tabPane.addMouseListener(new MouseAdapter()
        {
            public void mousePressed(MouseEvent e)
            {
                JTabbedPane tabPane = (JTabbedPane) e.getSource();

                int tabIndex = tabPane.getUI().tabForCoordinate(tabPane, e.getX(), e.getY());

                if (tabIndex >= 0 && tabPane.isEnabledAt(tabIndex))
                {
                    if (tabIndex == tabPane.getSelectedIndex())
                    {
                        if (tabPane.isRequestFocusEnabled())
                        {
                            tabPane.requestFocus();

                            tabPane.repaint(tabPane.getUI().getTabBounds(tabPane, tabIndex));
                        }
                    } else
                    {
                        tabPane.setSelectedIndex(tabIndex);
                    }

                    if (!tabPane.isEnabled() || SwingUtilities.isRightMouseButton(e))
                    {
                        final JPopupMenu popupMenu = new JPopupMenu();

                        final JMenuItem popWindow = new JMenuItem("Pop window out");
                        popWindow.addActionListener(e1 ->
                        {
                            final int selectedIndex = tabPane.getSelectedIndex();
                            final String tabName = tabPane.getTitleAt(selectedIndex);
                            final JComponent selectedComponent = (JComponent) tabPane.getSelectedComponent();

                            // Pops up the selected tab.
                            final WindowController.WindowToTab windowToTab = WindowController.WindowToTab.parseString(tabName);

                            switch (windowToTab)
                            {
                                case offline:
                                    WindowController.buildOfflineWindow(selectedComponent);
                                    WindowController.showOfflineWindow();
                                    break;
                                case online:
                                    WindowController.buildOnlineWindow(selectedComponent);
                                    WindowController.showOnlineWindow();
                                    break;
                                case report:
                                    WindowController.buildReportWindow(selectedComponent);
                                    WindowController.showReportWindow();
                                    break;
                                default:
                                    return;
                            }

                            tabPane.setSelectedIndex(0);
                        });

                        // Disabling the pop up button for the network state tab.
                        if (WindowController.WindowToTab.parseString(tabPane.getTitleAt(tabPane.getSelectedIndex())) == WindowController.WindowToTab.network)
                        {
                            popWindow.setEnabled(false);
                        }

                        popupMenu.add(popWindow);

                        popupMenu.show(e.getComponent(), e.getX(), e.getY());
                    }
                }
            }
        });

        // Building windows
        WindowController.buildControlWindow(tabPane);

        addAllKeyCombinationActions();
    }


    private JPanel configureLeftBottomPanel()
    {
        txt_netPlanLog = new JTextArea();
        txt_netPlanLog.setFont(new JLabel().getFont());
        JPanel pane = new JPanel(new MigLayout("fill, insets 0 0 0 0"));
        pane.setBorder(BorderFactory.createTitledBorder(new LineBorder(Color.BLACK), "Warnings"));
        pane.add(new JScrollPane(txt_netPlanLog), "grow");
        return pane;
    }

    @Override
    public String getDescription()
    {
        return getName();
    }

    @Override
    public KeyStroke getKeyStroke()
    {
        return KeyStroke.getKeyStroke(KeyEvent.VK_1, InputEvent.ALT_DOWN_MASK);
    }

    @Override
    public String getMenu()
    {
        return "Tools|" + TITLE;
    }

    @Override
    public String getName()
    {
        return TITLE + " (GUI)";
    }

    @Override
    public List<Triple<String, String, String>> getParameters()
    {
        return null;
    }

    @Override
    public int getPriority()
    {
        return Integer.MAX_VALUE;
    }


    private void updateLog(String text)
    {
        txt_netPlanLog.setText(null);
        txt_netPlanLog.setText(text);
        txt_netPlanLog.setCaretPosition(0);
    }

    @Override
    public void updateVisualizationAfterChanges (Set<NetworkElementType> modificationsMade)
    {
    	if ((modificationsMade == null) ||  (modificationsMade.contains(NetworkElementType.LINK) || modificationsMade.contains(NetworkElementType.NODE)))
    	{
	   		vs.rebuildVisualizationState(null);
   	        topologyPanel.getCanvas().refresh();
   	        viewEditTopTables.updateView();
   	        updateWarnings();
    	}
    	else 
    	{
   	        viewEditTopTables.updateView();
   	        updateWarnings();
    	}
    }

//    @Override
//    public void updateVisualizationFocus (NetworkElementType type , long id)
//    {
//        viewEditTopTables.selectViewItem(NetworkElementType.LINK , id);
//    }
//
//    @Override
//    public void updateVisualizationFocus (NetworkElementType type , int indexDemand , int indexLink)
//    {
//    	if (type != NetworkElementType.FORWARDING_RULE) throw new RuntimeException("Bad");
//        viewEditTopTables.selectViewItem(NetworkElementType.FORWARDING_RULE , Pair.of(indexDemand,indexLink));
//    }
    
//    @Override
//    public Link addLink (NetworkLayer layer , Node originNode, Node destinationNode , boolean updateView)
//    {
//        if (!vs.isNetPlanEditable()) throw new UnsupportedOperationException("Not supported");
//   		Link e = getDesign().addLink(originNode , destinationNode , 0 , 0 , 200000 , null ,  layer);
//   		if (updateView)
//   		{
//   	   		vs.rebuildVisualizationState(null);
//   	        topologyPanel.getCanvas().refresh();
//   	        viewEditTopTables.updateView();
//   	        viewEditTopTables.selectViewItem(NetworkElementType.LINK , e.getId());
//   	        updateWarnings();
//   		}
//        return e;
//    }
//
//    @Override
//    public Demand addDemand (NetworkLayer layer , Node originNode, Node destinationNode , boolean updateView)
//    {
//        if (!vs.isNetPlanEditable()) throw new UnsupportedOperationException("Not supported");
//   		Demand d = getDesign().addDemand(originNode , destinationNode , 0 , null ,  layer);
//   		if (updateView)
//   		{
//   	        viewEditTopTables.updateView();
//   	        viewEditTopTables.selectViewItem(NetworkElementType.DEMAND , d.getId());
//   	        updateWarnings();
//   		}
//        return d;
//    }
//
//    
//    @Override
//    public Pair<Demand,Demand> addDemandBidirectional (NetworkLayer layer, Node originNode, Node destinationNode , boolean updateView)
//    {
//        if (!vs.isNetPlanEditable()) throw new UnsupportedOperationException("Not supported");
//   		Pair<Demand,Demand> d = getDesign().addDemandBidirectional(originNode , destinationNode , 0 , null ,  layer);
//   		if (updateView)
//   		{
//   	        viewEditTopTables.updateView();
//   	        viewEditTopTables.selectViewItem(NetworkElementType.DEMAND , d.getFirst().getId());
//   	        updateWarnings();
//   		}
//        return d;
//    }
//    
//    @Override
//    public Pair<Link, Link> addLinkBidirectional (NetworkLayer layer , Node originNode, Node destinationNode , boolean updateView)
//    {
//        if (!vs.isNetPlanEditable()) throw new UnsupportedOperationException("Not supported");
//
//        NetPlan netPlan = getDesign();
//        Pair<Link, Link> links = netPlan.addLinkBidirectional(originNode, destinationNode, 0, 0, 200000, null, layer);
//        if (updateView)
//        {
//        	vs.rebuildVisualizationState(null);
//            topologyPanel.getCanvas().rebuildTopologyAndRefresh();
//            viewEditTopTables.updateView();
//            viewEditTopTables.selectViewItem(NetworkElementType.LINK , links.getFirst().getId());
//            updateWarnings();
//        }
//        return Pair.of(links.getFirst(), links.getSecond());
//    }
//    
//    @Override
//    public Node addNode (Point2D pos , boolean updateView)
//    {
//        if (!vs.isNetPlanEditable()) throw new UnsupportedOperationException("Not supported");
//
//        Point2D.Double netPlanPos = OSMMapStateBuilder.getSingleton().translateNodeBaseCoordinatesIntoNetPlanCoordinates(getTopologyPanel().getCanvas() , pos);
//   		Node n = getDesign().addNode(netPlanPos.getX() , netPlanPos.getY() , "Node" + getDesign().getNumberOfNodes() , null);
//   		if (updateView)
//   		{
//   	        vs.rebuildVisualizationState(null);
//   	        topologyPanel.getCanvas().rebuildTopologyAndRefresh();
//   	        OSMMapStateBuilder.getSingleton().restartMapState(false);
//   	        viewEditTopTables.updateView();
//   	        viewEditTopTables.selectViewItem(NetworkElementType.NODE , n.getId());
//   	        updateWarnings();
//   		}
//        return n;
//    }
//
//    @Override
//    public void applyTopologyRearrangementAndUpdateView (ITopologyDistribution distribution)
//    {
//        final Map<Node, Point2D> nodePositionInNetPlanCoord = distribution.getNodeDistribution(currentNetPlan.getNodes());
//
//        for (Node node : currentNetPlan.getNodes())
//        {
//        	node.setXYPositionMap(nodePositionInNetPlanCoord.get(node));
//        	for (GUINode gn : vs.getVerticallyStackedGUINodes(node)) 
//        		topologyPanel.getCanvas().updateNodeXYPosition(gn);
//        }
//        topologyPanel.getCanvas().refresh();
//        topologyPanel.zoomAll();
//        viewEditTopTables.updateView();
//    }
//
//    @Override
//    public void setNodeVisibilityStateAndUpdateView (Node node, boolean setAsVisible)
//    {
//    	vs.setVisibilityState(node , setAsVisible);
//    	topologyPanel.getCanvas().refresh();
//    }
//    
//    @Override
//    public void setNodeNameAndUpdateView (Node node, String name)
//    {
//    	node.setName(name);
//    	topologyPanel.getCanvas().refresh();
//    }
//
//    @Override
//    public void setNodeFailureState (Node node, boolean isUp , boolean updateView)
//    {
//        node.setFailureState(isUp);
//        if (updateView)
//        {
//            topologyPanel.getCanvas().refresh();
//            viewEditTopTables.updateView();
//            updateWarnings();
//        }
//    }
//    
//    @Override
//    public void setLinkFailureState (Link link , boolean isUp , boolean updateView)
//    {
//        link.setFailureState(isUp);
//        if (updateView)
//        {
//            topologyPanel.getCanvas().refresh();
//            viewEditTopTables.updateView();
//            updateWarnings();
//        }
//    }

    @Override
    public void moveNodeXYPosition (Node node, Point2D posInNetPlanCoordinates , boolean updateView)
    {
        if (!vs.isNetPlanEditable()) throw new UnsupportedOperationException("Not supported");

        /* Change the netplan position */
        node.setXYPositionMap(posInNetPlanCoordinates);
        
        if (updateView)
        {
            /* Just updates the X,Y columns in the table */
            ClassAwareTableModel nodeTableModel = (ClassAwareTableModel) viewEditTopTables.getNetPlanViewTable().get(NetworkElementType.NODE).getModel();
            int numRows = nodeTableModel.getRowCount();
            for (int row = 0; row < numRows; row++)
            {
                if ((long) nodeTableModel.getValueAt(row, 0) == node.getId())
                {
                    nodeTableModel.setAtValueSuper(node.getXYPositionMap().getX(), row, AdvancedJTable_node.COLUMN_XCOORD);
                    nodeTableModel.setAtValueSuper(node.getXYPositionMap().getY(), row, AdvancedJTable_node.COLUMN_YCOORD);
                }
            }
            
            for (GUINode gn : vs.getVerticallyStackedGUINodes(node)) topologyPanel.getCanvas().updateNodeXYPosition(gn);
            topologyPanel.getCanvas().refresh();
        }
    }


    @Override
    public NetPlan getDesign()
    {
        if (inOnlineSimulationMode()) return onlineSimulationPane.getSimKernel().getCurrentNetPlan();
        else return currentNetPlan;
    }

    @Override
    public NetPlan getInitialDesign()
    {
        if (inOnlineSimulationMode()) return onlineSimulationPane.getSimKernel().getInitialNetPlan();
        else return null;
    }

//    @Override
//    public void setDemandOfferedTraffic (Demand d , double traffic , boolean updateView)
//    {
//    	d.setOfferedTraffic(traffic);
//    	if (updateView)
//    		viewEditTopTables.updateView();
//    }
//    
//    @Override
//    public void removeNetworkElementAndUpdateView (NetworkElement e)
//    {
//    	boolean updateCanvas = (e instanceof Node) || (e instanceof Link) || (e instanceof NetworkLayer);
//    	if (e instanceof Demand) ((Demand) e).remove();
//    	else if (e instanceof Demand) ((Demand) e).remove();
//    	else if (e instanceof Link) ((Link) e).remove();
//    	else if (e instanceof MulticastDemand) ((MulticastDemand) e).remove();
//    	else if (e instanceof MulticastTree) ((MulticastTree) e).remove();
//    	else if (e instanceof NetworkLayer) e.getNetPlan().removeNetworkLayer((NetworkLayer) e);
//    	else if (e instanceof Node) ((Node) e).remove();
//    	else if (e instanceof Resource) ((Resource) e).remove();
//    	else if (e instanceof Route) ((Route) e).remove();
//    	else if (e instanceof SharedRiskGroup) ((SharedRiskGroup) e).remove();
//    	else throw new RuntimeException ("Bad");
//    		
//    	if (updateCanvas) 
//            topologyPanel.getCanvas().rebuildTopologyAndRefresh();
//        viewEditTopTables.updateView();
//        updateWarnings();
//    }
//
//    @Override
//    public void removeAllNetworkElementsOfaType (NetworkElementType type , NetworkLayer layer)
//    {
//    	final NetPlan np = getDesign();
//    	boolean updateCanvas = (type == NetworkElementType.NODE) || (type == NetworkElementType.LINK) || (type == NetworkElementType.LAYER);
//    	if (type == NetworkElementType.DEMAND) np.removeAllDemands(layer);
//    	else if (type == NetworkElementType.LINK) np.removeAllLinks(layer);
//    	else if (type == NetworkElementType.MULTICAST_DEMAND) np.removeAllMulticastDemands(layer);
//    	else if (type == NetworkElementType.MULTICAST_TREE) np.removeAllMulticastTrees(layer);
//    	else if (type == NetworkElementType.LAYER) np.removeAllNetworkLayers();
//    	else if (type == NetworkElementType.NODE) np.removeAllNodes();
//    	else if (type == NetworkElementType.RESOURCE) np.removeAllResources();
//    	else if (type == NetworkElementType.ROUTE) np.removeAllRoutes(layer);
//    	else if (type == NetworkElementType.FORWARDING_RULE) np.removeAllForwardingRules(layer);
//    	else throw new RuntimeException ("Bad");
//    		
//    	if (updateCanvas) 
//            topologyPanel.getCanvas().rebuildTopologyAndRefresh();
//        viewEditTopTables.updateView();
//        updateWarnings();
//    }

    
    @Override
    public void loadDesignDoNotUpdateVisualization (NetPlan netPlan)
    {
        netPlan.checkCachesConsistency();
        if (onlineSimulationPane != null) onlineSimulationPane.getSimKernel().setNetPlan(netPlan);
        currentNetPlan = netPlan;
        netPlan.checkCachesConsistency();

        // Saving original topology structure
//        initialTopologySetting = new TopologyMap();
//        currentNetPlan.getNodes().stream().forEach(node -> initialTopologySetting.addNodeLocation(node.getId(), node.getXYPositionMap()));
    }

//    @Override
//    public void loadDesign (NetPlan netPlan)
//    {
//        viewEditTopTables.resetTables();
//        netPlan.checkCachesConsistency();
//        if (onlineSimulationPane != null) onlineSimulationPane.getSimKernel().setNetPlan(netPlan);
//        currentNetPlan = netPlan;
//        netPlan.checkCachesConsistency();
//
//        // Saving original topology structure
//        initialTopologySetting = new TopologyMap();
//        currentNetPlan.getNodes().stream().forEach(node -> initialTopologySetting.addNodeLocation(node.getId(), node.getXYPositionMap()));
//
//        topologyPanel.updateLayerChooser();
//        topologyPanel.getCanvas().zoomAll();
//        resetView();
//    }


//    @Override
//    public void removeLink(long link)
//    {
//        if (!vs.isNetPlanEditable()) throw new UnsupportedOperationException("Not supported");
//
//        NetPlan netPlan = getDesign();
////        if (netPlan.getLinkFromId(link).getLayer().equals(getDesign().getNetworkLayerDefault()))
////        {
////            topologyPanel.getCanvas().removeLink(netPlan.getLinkFromId(link));
////            topologyPanel.getCanvas().refresh();
////        }
//        netPlan.getLinkFromId(link).remove();
//        vs.rebuildVisualizationState(null);
//        topologyPanel.getCanvas().refresh();
//        updateWarningsAndTables();
//    }
//
//    @Override
//    public void removeNode(long node)
//    {
//        if (!vs.isNetPlanEditable()) throw new UnsupportedOperationException("Not supported");
//
//        NetPlan netPlan = getDesign();
////        topologyPanel.getCanvas().removeNode(netPlan.getNodeFromId(node));
////        topologyPanel.getCanvas().refresh();
//        netPlan.getNodeFromId(node).remove();
//        vs.rebuildVisualizationState(null);
//        topologyPanel.getCanvas().refresh();
//        updateWarningsAndTables();
//    }

    private void resetButton()
    {
        try
        {
            final int result = JOptionPane.showConfirmDialog(null, "Are you sure you want to reset? This will remove all unsaved data", "Reset", JOptionPane.YES_NO_OPTION);
            if (result != JOptionPane.YES_OPTION) return;

            if (inOnlineSimulationMode())
            {
                switch (onlineSimulationPane.getSimKernel().getSimCore().getSimulationState())
                {
                    case NOT_STARTED:
                    case STOPPED:
                        break;
                    default:
                        onlineSimulationPane.getSimKernel().getSimCore().setSimulationState(SimState.STOPPED);
                        break;
                }
                onlineSimulationPane.getSimKernel().reset();
                loadDesignDoNotUpdateVisualization(onlineSimulationPane.getSimKernel().getCurrentNetPlan());
            } else
            {
                loadDesignDoNotUpdateVisualization(new NetPlan());
                //algorithmSelector.reset();
                executionPane.reset();
            }
//            reportSelector.reset();
//            reportContainer.removeAll();
        } catch (Throwable ex)
        {
            ErrorHandling.addErrorOrException(ex, GUINetworkDesign.class);
            ErrorHandling.showErrorDialog("Unable to reset");
        }
        updateVisualizationAfterNewTopology();
    }

    
    @Override
    public void resetPickedStateAndUpdateView ()
    {
        vs.resetColorAndShapeState();
        topologyPanel.getCanvas().resetPickedStateAndRefresh();
        viewEditTopTables.getNetPlanViewTable().get(NetworkElementType.DEMAND).clearSelection();
        viewEditTopTables.getNetPlanViewTable().get(NetworkElementType.MULTICAST_DEMAND).clearSelection();
        viewEditTopTables.getNetPlanViewTable().get(NetworkElementType.FORWARDING_RULE).clearSelection();
        viewEditTopTables.getNetPlanViewTable().get(NetworkElementType.LINK).clearSelection();
        viewEditTopTables.getNetPlanViewTable().get(NetworkElementType.NODE).clearSelection();
        viewEditTopTables.getNetPlanViewTable().get(NetworkElementType.MULTICAST_TREE).clearSelection();
        viewEditTopTables.getNetPlanViewTable().get(NetworkElementType.SRG).clearSelection();
        viewEditTopTables.getNetPlanViewTable().get(NetworkElementType.RESOURCE).clearSelection();
    }

    @Override
    public void pickDemandAndUpdateView (Demand demand)
    {
        NetworkLayer layer = demand.getLayer();
        selectNetPlanViewItem(layer.getId(), NetworkElementType.DEMAND, demand.getId());

        vs.setNodeProperties(Arrays.asList(vs.getAssociatedGUINode(demand.getIngressNode() , layer)) , COLOR_INITIALNODE , null , -1);
        vs.setNodeProperties(Arrays.asList(vs.getAssociatedGUINode(demand.getEgressNode() , layer)) , COLOR_ENDNODE , null , -1);
        Pair<Set<Link>,Set<Link>> linksOccupiedThisLayer = demand.getLinksWithOccupiedCapacity();
        Set<GUILink> linksToShowPrimary = new HashSet<> ();
        Set<GUILink> linksToShowBackup = new HashSet<> ();
        for (Link e : linksOccupiedThisLayer.getFirst())
        {
        	Pair<Set<GUILink>,Set<GUILink>> pairThisLink = vs.getAssociatedGUILinksIncludingCoupling(e , true);
        	linksToShowPrimary.addAll (pairThisLink.getFirst());
        	linksToShowBackup.addAll (pairThisLink.getSecond());
        }
        for (Link e : linksOccupiedThisLayer.getSecond())
        {
        	Pair<Set<GUILink>,Set<GUILink>> pairThisLink = vs.getAssociatedGUILinksIncludingCoupling(e , false);
        	linksToShowPrimary.addAll (pairThisLink.getFirst());
        	linksToShowBackup.addAll (pairThisLink.getSecond());
        }
        vs.setLinkProperties(linksToShowPrimary , 
        		Color.BLUE , VisualizationState.DEFAULT_REGGUILINK_ARROWSTROKE_PICKED , 
        		true , true);
        vs.setLinkProperties(linksToShowBackup, 
        		Color.YELLOW , VisualizationState.DEFAULT_REGGUILINK_EDGESTROKE_BACKUP_PICKED , 
        		true , true);

        topologyPanel.getCanvas().refresh();
    }

//    @Override
//    public void showMulticastDemand(long demandId)
//    {
//        NetPlan netPlan = getDesign();
//        MulticastDemand demand = netPlan.getMulticastDemandFromId(demandId);
//        NetworkLayer layer = demand.getLayer();
//        selectNetPlanViewItem(layer.getId(), NetworkElementType.MULTICAST_DEMAND, demandId);
//
//        Map<Node, Color> nodes = new HashMap<Node, Color>();
//        nodes.put(demand.getIngressNode(), COLOR_INITIALNODE);
//        for (Node n : demand.getEgressNodes()) nodes.put(n, COLOR_ENDNODE);
//        Map<Link, Pair<Color, Boolean>> links = new HashMap<Link, Pair<Color, Boolean>>();
//
//        DoubleMatrix1D x_e = netPlan.getMatrixMulticastDemand2LinkTrafficCarried(layer).viewRow(demand.getIndex()).copy();
//        for (int e = 0; e < x_e.size(); e++)
//            if (x_e.get(e) > 0) links.put(netPlan.getLinkFromId(e), Pair.of(Color.BLUE, false));
//        topologyPanel.getCanvas().showAndPickNodesAndLinks(nodes, links);
//        topologyPanel.getCanvas().refresh();
//    }

//    @Override
//    public void showForwardingRule(Pair<Integer, Integer> demandLink)
//    {
//        NetPlan netPlan = getDesign();
//        Demand demand = netPlan.getDemand(demandLink.getFirst());
//        Link link = netPlan.getLink(demandLink.getSecond());
//        NetworkLayer layer = demand.getLayer();
//        selectNetPlanViewItem(layer.getId(), NetworkElementType.FORWARDING_RULE, Pair.of(demand.getIndex(), link.getIndex()));
//
//        Map<Node, Color> nodes = new HashMap<Node, Color>();
//        nodes.put(demand.getIngressNode(), COLOR_INITIALNODE);
//        nodes.put(demand.getEgressNode(), COLOR_ENDNODE);
//        Map<Link, Pair<Color, Boolean>> links = new HashMap<Link, Pair<Color, Boolean>>();
//        links.put(link, Pair.of(Color.BLUE, false));
//        topologyPanel.getCanvas().showAndPickNodesAndLinks(nodes, links);
//        topologyPanel.getCanvas().refresh();
//    }
//
//    @Override
//    public void showLink(long linkId)
//    {
//        NetPlan netPlan = getDesign();
//        Link link = netPlan.getLinkFromId(linkId);
//        selectNetPlanViewItem(link.getLayer().getId(), NetworkElementType.LINK, linkId);
//
//        topologyPanel.getCanvas().showNode(link.getOriginNode(), COLOR_INITIALNODE);
//        topologyPanel.getCanvas().showNode(link.getDestinationNode(), COLOR_ENDNODE);
//
//        topologyPanel.getCanvas().showLink(link, link.isUp() ? Color.BLUE : Color.RED, false);
//        topologyPanel.getCanvas().refresh();
//    }
//
//    @Override
//    public void showNode(long nodeId)
//    {
//        selectNetPlanViewItem(getDesign().getNetworkLayerDefault().getId(), NetworkElementType.NODE, nodeId);
//
//        topologyPanel.getCanvas().showNode(getDesign().getNodeFromId(nodeId), Color.BLUE);
//        topologyPanel.getCanvas().refresh();
//    }
//
//    @Override
//    public void showRoute(long routeId) // yellow segment link not used, orange segment link used, blue not segment link used. The same for initial state, in dashed
//    {
//        NetPlan netPlan = getDesign();
//        Route route = netPlan.getRouteFromId(routeId);
//        NetworkLayer layer = route.getLayer();
//        selectNetPlanViewItem(layer.getId(), NetworkElementType.ROUTE, routeId);
//
//        NetPlan initialState = getInitialDesign();
//
//        Map<Node, Color> selectedNodes = new HashMap<>();
//        Map<Link, Pair<Color, Boolean>> coloredLinks = new HashMap<Link, Pair<Color, Boolean>>();
//        if (inOnlineSimulationMode() && viewEditTopTables.isInitialNetPlanShown())
//        {
//            Route initialRoute = initialState.getRouteFromId(route.getId());
//            if (initialRoute != null)
//            {
//                for (Route s : initialRoute.getBackupRoutes())
//                    for (Link e : s.getSeqLinks())
//                        if (netPlan.getLinkFromId(e.getId()) != null)
//                        {
//                            Link selectedLink = netPlan.getLinkFromId(e.getId());
//                            selectedNodes.put(selectedLink.getOriginNode(), Color.YELLOW);
//                            selectedNodes.put(selectedLink.getDestinationNode(), Color.YELLOW);
//                            coloredLinks.put(selectedLink, Pair.of(Color.YELLOW, true));
//                        }
//                for (Link link : initialRoute.getSeqLinks())
//                	if (netPlan.getLinkFromId(link.getId()) != null)
//                    {
//                        Link selectedLink = netPlan.getLinkFromId(link.getId());
//                        selectedNodes.put(selectedLink.getOriginNode(), Color.BLUE);
//                        selectedNodes.put(selectedLink.getDestinationNode(), Color.BLUE);
//                        coloredLinks.put(selectedLink, Pair.of(Color.BLUE, true));
//                    }
//            }
//        }
//        for (Route s : route.getBackupRoutes())
//            for (Link e : s.getSeqLinks())
//            {
//                selectedNodes.put(e.getOriginNode(), Color.YELLOW);
//                selectedNodes.put(e.getDestinationNode(), Color.YELLOW);
//                coloredLinks.put(e, Pair.of(Color.YELLOW, false));
//            }
//        for (Link linkOrSegment : route.getSeqLinks())
//        {
//            selectedNodes.put(linkOrSegment.getOriginNode(), Color.BLUE);
//            selectedNodes.put(linkOrSegment.getDestinationNode(), Color.BLUE);
//            coloredLinks.put(linkOrSegment, Pair.of(Color.BLUE, false));
//        }
//
//        topologyPanel.getCanvas().showAndPickNodesAndLinks(selectedNodes, coloredLinks);
//        topologyPanel.getCanvas().refresh();
//    }
//
//    @Override
//    public void showMulticastTree(long treeId)
//    {
//        NetPlan netPlan = getDesign();
//        MulticastTree tree = netPlan.getMulticastTreeFromId(treeId);
//        NetworkLayer layer = tree.getLayer();
//        selectNetPlanViewItem(layer.getId(), NetworkElementType.MULTICAST_TREE, treeId);
//
//        NetPlan currentState = getDesign();
//        NetPlan initialState = getInitialDesign();
//        Map<Node, Color> coloredNodes = new HashMap<Node, Color>();
//        Map<Link, Pair<Color, Boolean>> coloredLinks = new HashMap<Link, Pair<Color, Boolean>>();
//        if (inOnlineSimulationMode() && viewEditTopTables.isInitialNetPlanShown())
//        {
//            MulticastTree initialTree = initialState.getMulticastTreeFromId(treeId);
//            if (initialTree != null)
//                for (Link e : initialTree.getLinkSet())
//                    if (currentState.getLinkFromId(e.getId()) != null)
//                        coloredLinks.put(currentState.getLinkFromId(e.getId()), Pair.of(Color.BLUE, true));
//        }
//        for (Link e : tree.getLinkSet()) coloredLinks.put(e, Pair.of(Color.BLUE, false));
//        coloredNodes.put(tree.getIngressNode(), COLOR_INITIALNODE);
//        for (Node n : tree.getEgressNodes()) coloredNodes.put(n, COLOR_ENDNODE);
//        topologyPanel.getCanvas().showAndPickNodesAndLinks(coloredNodes, coloredLinks);
//        topologyPanel.getCanvas().refresh();
//    }
//
//    @Override
//    public void showSRG(long srg)
//    {
//        showSRG(getDesign().getNetworkLayerDefault().getId(), srg);
//    }
//
//    @Override
//    public void showSRG(long layer, long srg)
//    {
//        NetPlan netPlan = getDesign();
//        selectNetPlanViewItem(layer, NetworkElementType.SRG, srg);
//
//        Set<Node> nodeIds_thisSRG = netPlan.getSRGFromId(srg).getNodes();
//        Set<Link> linkIds_thisSRG_thisLayer = netPlan.getSRGFromId(srg).getLinks(netPlan.getNetworkLayerFromId(layer));
//        Map<Node, Color> nodeColors = new HashMap<Node, Color>();
//        Map<Link, Pair<Color, Boolean>> linkColors = new HashMap<Link, Pair<Color, Boolean>>();
//        for (Node n : nodeIds_thisSRG) nodeColors.put(n, Color.ORANGE);
//        for (Link e : linkIds_thisSRG_thisLayer) linkColors.put(e, Pair.of(Color.ORANGE, false));
//
//        topologyPanel.getCanvas().showAndPickNodesAndLinks(nodeColors, linkColors);
//        topologyPanel.getCanvas().refresh();
//    }

    /**
     * Shows the tab corresponding associated to a network element.
     *
     * @param layer  Layer identifier
     * @param type   Network element type
     * @param itemId Item identifier (if null, it will just show the tab)
     * @since 0.3.0
     */
    private void selectNetPlanViewItem(long layer, NetworkElementType type, Object itemId)
    {
        topologyPanel.selectLayer(layer);
        viewEditTopTables.selectViewItem(type, itemId);
    }

    /**
     * Indicates whether or not the initial {@code NetPlan} object is stored to be
     * compared with the current one (i.e. after some simulation steps).
     *
     * @return {@code true} if the initial {@code NetPlan} object is stored. Otherwise, {@code false}.
     * @since 0.3.0
     */
    public boolean inOnlineSimulationMode()
    {
        if (onlineSimulationPane == null) return false;
        final SimState simState = onlineSimulationPane.getSimKernel().getSimCore().getSimulationState();
        if (simState == SimState.PAUSED || simState == SimState.RUNNING || simState == SimState.STEP)
            return true;
        else return false;
    }

    public void updateWarnings()
    {
        Map<String, String> net2planParameters = Configuration.getNet2PlanOptions();
        List<String> warnings = NetworkPerformanceMetrics.checkNetworkState(getDesign(), net2planParameters);
        String warningMsg = warnings.isEmpty() ? "Design is successfully completed!" : StringUtils.join(warnings, StringUtils.getLineSeparator());
        updateLog(warningMsg);
    }

//    /**
//     * Shows the {@code NetPlan} view, moving to the corresponding tab.
//     *
//     * @since 0.3.0
//     */
//    @Override
//    public final void showNetPlanView()
//    {
//        viewEditTopTables.getNetPlanView().setSelectedIndex(0);
//    }

//    @Override
//    public TopologyPanel getTopologyPanel()
//    {
//        return topologyPanel;
//    }

    private void addAllKeyCombinationActions()
    {
        addKeyCombinationAction("Resets the tool", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                resetButton();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_R, InputEvent.CTRL_DOWN_MASK));

        addKeyCombinationAction("Outputs current design to console", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                System.out.println(getDesign().toString());
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_F11, InputEvent.CTRL_DOWN_MASK));

        /* FROM THE OFFLINE ALGORITHM EXECUTION */

        addKeyCombinationAction("Execute algorithm", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                executionPane.doClickInExecutionButton();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_E, KeyEvent.CTRL_DOWN_MASK));

        /* From the TOPOLOGY PANEL */
        addKeyCombinationAction("Load design", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                topologyPanel.loadDesign();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_O, InputEvent.CTRL_DOWN_MASK));

        addKeyCombinationAction("Save design", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                topologyPanel.saveDesign();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_S, InputEvent.CTRL_DOWN_MASK));

        addKeyCombinationAction("Zoom in", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                topologyPanel.zoomIn();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_ADD, InputEvent.CTRL_DOWN_MASK), KeyStroke.getKeyStroke(KeyEvent.VK_PLUS, InputEvent.CTRL_DOWN_MASK));

        addKeyCombinationAction("Zoom out", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                topologyPanel.zoomOut();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_SUBTRACT, InputEvent.CTRL_DOWN_MASK), KeyStroke.getKeyStroke(KeyEvent.VK_MINUS, InputEvent.CTRL_DOWN_MASK));

        addKeyCombinationAction("Zoom all", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                topologyPanel.zoomAll();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_MULTIPLY, InputEvent.CTRL_DOWN_MASK));

        addKeyCombinationAction("Take snapshot", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                topologyPanel.takeSnapshot();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_F12, InputEvent.CTRL_DOWN_MASK));

        addKeyCombinationAction("Load traffic demands", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                topologyPanel.loadTrafficDemands();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_T, InputEvent.CTRL_DOWN_MASK));
        
        /* FROM REPORT */
        addKeyCombinationAction("Close selected report", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                int tab = reportPane.getReportContainer().getSelectedIndex();
                if (tab == -1) return;
                reportPane.getReportContainer().remove(tab);
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_W, InputEvent.CTRL_DOWN_MASK));

        addKeyCombinationAction("Close all reports", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                reportPane.getReportContainer().removeAll();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_W, InputEvent.CTRL_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK));


        /* Online simulation */
        addKeyCombinationAction("Run simulation", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                try
                {
                    if (onlineSimulationPane.isRunButtonEnabled()) onlineSimulationPane.runSimulation(false);
                } catch (Net2PlanException ex)
                {
                    if (ErrorHandling.isDebugEnabled())
                        ErrorHandling.addErrorOrException(ex, OnlineSimulationPane.class);
                    ErrorHandling.showErrorDialog(ex.getMessage(), "Error executing simulation");
                } catch (Throwable ex)
                {
                    ErrorHandling.addErrorOrException(ex, OnlineSimulationPane.class);
                    ErrorHandling.showErrorDialog("An error happened");
                }

            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_U, InputEvent.CTRL_DOWN_MASK));

        // Windows
        addKeyCombinationAction("Show control window", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e) {
                WindowController.showControlWindow();
            }
        }, KeyStroke.getKeyStroke(KeyEvent.VK_1, ActionEvent.ALT_MASK + ActionEvent.SHIFT_MASK));
    }

	@Override
	public VisualizationState getVisualizationState()
	{
		return vs;
	}

	@Override
	public void updateVisualizationAfterLinkNodeColorChanges()
	{
	    topologyPanel.getCanvas().refresh();
	}

	@Override
	public void updateVisualizationJustTables()
	{
	    viewEditTopTables.updateView();
	}

	@Override
	public void pickLinkAndUpdateView(Link link)
	{
		// TODO Auto-generated method stub
		
	}

	@Override
	public void pickNodeAndUpdateView(Node node)
	{
		// TODO Auto-generated method stub
		
	}

	@Override
	public void pickMulticastDemandAndUpdateView(MulticastDemand demand)
	{
		// TODO Auto-generated method stub
		
	}

	@Override
	public void pickForwardingRuleAndUpdateView(Pair<Demand, Link> demandLink)
	{
		// TODO Auto-generated method stub
		
	}

	@Override
	public void pickRouteAndUpdateView(Route route)
	{
		// TODO Auto-generated method stub
		
	}

	@Override
	public void pickMulticastTreeAndUpdateView(MulticastTree tree)
	{
		// TODO Auto-generated method stub
		
	}

	@Override
	public void pickSRGAndUpdateView(NetworkLayer layer, SharedRiskGroup srg)
	{
		// TODO Auto-generated method stub
		
	}

	@Override
	public void putColorInElementTopologyCanvas(Collection<? extends NetworkElement> linksAndNodes, Color color)
	{
		// TODO Auto-generated method stub
		
	}

	@Override
	public void updateVisualizationAfterNewTopology()
	{
		vs.rebuildVisualizationState(null);
	    topologyPanel.getCanvas().refresh();
	    topologyPanel.getCanvas().zoomAll();
	    viewEditTopTables.updateView();
	    updateWarnings();
	}

	@Override
	public void justApplyZoomAll()
	{
	    topologyPanel.getCanvas().zoomAll();
	}

	@Override
	public void updateVisualizationJustTopologyCanvas()
	{
		vs.rebuildVisualizationState(null);
	    topologyPanel.getCanvas().refresh();
	}


}
