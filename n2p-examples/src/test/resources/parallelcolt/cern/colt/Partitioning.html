<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_21) on Mon Jul 29 22:10:45 CEST 2013 -->
<meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
<title>Partitioning (Parallel Colt 0.10.1 - API Specification)</title>
<meta name="date" content="2013-07-29">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Partitioning (Parallel Colt 0.10.1 - API Specification)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Partitioning.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><em><b>Parallel Colt 0.10.1</b></em></div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../cern/colt/ParallelQuickSort.html" title="class in cern.colt"><span class="strong">Prev Class</span></a></li>
<li><a href="../../cern/colt/PersistentObject.html" title="class in cern.colt"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?cern/colt/Partitioning.html" target="_top">Frames</a></li>
<li><a href="Partitioning.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">cern.colt</div>
<h2 title="Class Partitioning" class="title">Class Partitioning</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li><a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>cern.colt.Partitioning</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="strong">Partitioning</span>
extends <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a></pre>
<div class="block">Given some interval boundaries, partitions arrays such that all elements
 falling into an interval are placed next to each other.
 <p>
 The algorithms partition arrays into two or more intervals. They distinguish
 between <i>synchronously</i> partitioning either one, two or three arrays.
 They further come in templated versions, either partitioning <tt>int[]</tt>
 arrays or <tt>double[]</tt> arrays.
 <p>
 You may want to start out reading about the simplest case: Partitioning one
 <tt>int[]</tt> array into two intervals. To do so, read
 <a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int)"><code>partition(int[],int,int,int)</code></a>.
 
 Next, building upon that foundation comes a method partitioning
 <tt>int[]</tt> arrays into multiple intervals. See
 <a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int[], int, int, int[])"><code>partition(int[],int,int,int[],int,int,int[])</code></a> for related
 documentation.
 <p>
 All other methods are no different than the one's you now already understand,
 except that they operate on slightly different data types.
 <p>
 <b>Performance</b>
 <p>
 Partitioning into two intervals is <tt>O( N )</tt>. Partitioning into k
 intervals is <tt>O( N * log(k))</tt>. Constants factors are minimized. No
 temporary memory is allocated; Partitioning is in-place.</div>
<dl><dt><span class="strong">Version:</span></dt>
  <dd>1.0, 03-Jul-99</dd>
<dt><span class="strong">Author:</span></dt>
  <dd>wolfgang.hoschek@cern.ch</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="../../cern/colt/matrix/tdouble/algo/DoublePartitioning.html" title="class in cern.colt.matrix.tdouble.algo"><code>DoublePartitioning</code></a></dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../cern/colt/Partitioning.html#swappedElements">swappedElements</a></strong></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../cern/colt/Partitioning.html#dualPartition(double[], double[], int, int, double)">dualPartition</a></strong>(double[]&nbsp;list,
             double[]&nbsp;secondary,
             int&nbsp;from,
             int&nbsp;to,
             double&nbsp;splitter)</code>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#dualPartition(int[], int[], int, int, int)"><code>dualPartition(int[],int[],int,int,int)</code></a> except that it
 <i>synchronously</i> partitions <tt>double[]</tt> rather than
 <tt>int[]</tt> arrays.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../cern/colt/Partitioning.html#dualPartition(double[], double[], int, int, double[], int, int, int[])">dualPartition</a></strong>(double[]&nbsp;list,
             double[]&nbsp;secondary,
             int&nbsp;from,
             int&nbsp;to,
             double[]&nbsp;splitters,
             int&nbsp;splitFrom,
             int&nbsp;splitTo,
             int[]&nbsp;splitIndexes)</code>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#dualPartition(int[], int[], int, int, int[], int, int, int[])"><code>dualPartition(int[],int[],int,int,int[],int,int,int[])</code></a>
 except that it <i>synchronously</i> partitions <tt>double[]</tt> rather
 than <tt>int[]</tt> arrays.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../cern/colt/Partitioning.html#dualPartition(int[], int[], int, int, int)">dualPartition</a></strong>(int[]&nbsp;list,
             int[]&nbsp;secondary,
             int&nbsp;from,
             int&nbsp;to,
             int&nbsp;splitter)</code>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int)"><code>partition(int[],int,int,int)</code></a> except that this method
 <i>synchronously</i> partitions two arrays at the same time; both arrays
 are partially sorted according to the elements of the primary array.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../cern/colt/Partitioning.html#dualPartition(int[], int[], int, int, int[], int, int, int[])">dualPartition</a></strong>(int[]&nbsp;list,
             int[]&nbsp;secondary,
             int&nbsp;from,
             int&nbsp;to,
             int[]&nbsp;splitters,
             int&nbsp;splitFrom,
             int&nbsp;splitTo,
             int[]&nbsp;splitIndexes)</code>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int[], int, int, int[])"><code>partition(int[],int,int,int[],int,int,int[])</code></a> except that
 this method <i>synchronously</i> partitions two arrays at the same time;
 both arrays are partially sorted according to the elements of the primary
 array.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../cern/colt/Partitioning.html#genericPartition(int, int, int, int, int[], cern.colt.function.tint.IntComparator, cern.colt.function.tint.IntComparator, cern.colt.function.tint.IntComparator, cern.colt.Swapper)">genericPartition</a></strong>(int&nbsp;from,
                int&nbsp;to,
                int&nbsp;splitFrom,
                int&nbsp;splitTo,
                int[]&nbsp;splitIndexes,
                <a href="../../cern/colt/function/tint/IntComparator.html" title="interface in cern.colt.function.tint">IntComparator</a>&nbsp;comp,
                <a href="../../cern/colt/function/tint/IntComparator.html" title="interface in cern.colt.function.tint">IntComparator</a>&nbsp;comp2,
                <a href="../../cern/colt/function/tint/IntComparator.html" title="interface in cern.colt.function.tint">IntComparator</a>&nbsp;comp3,
                <a href="../../cern/colt/Swapper.html" title="interface in cern.colt">Swapper</a>&nbsp;swapper)</code>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int[], int, int, int[])"><code>partition(int[],int,int,int[],int,int,int[])</code></a> except that
 it <i>generically</i> partitions arbitrary shaped data (for example
 matrices or multiple arrays) rather than <tt>int[]</tt> arrays.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../cern/colt/Partitioning.html#partition(double[], int, int, double)">partition</a></strong>(double[]&nbsp;list,
         int&nbsp;from,
         int&nbsp;to,
         double&nbsp;splitter)</code>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int)"><code>partition(int[],int,int,int)</code></a> except that it partitions
 <tt>double[]</tt> rather than <tt>int[]</tt> arrays.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../cern/colt/Partitioning.html#partition(double[], int, int, double[], int, int, int[])">partition</a></strong>(double[]&nbsp;list,
         int&nbsp;from,
         int&nbsp;to,
         double[]&nbsp;splitters,
         int&nbsp;splitFrom,
         int&nbsp;splitTo,
         int[]&nbsp;splitIndexes)</code>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int[], int, int, int[])"><code>partition(int[],int,int,int[],int,int,int[])</code></a> except that
 it partitions <tt>double[]</tt> rather than <tt>int[]</tt> arrays.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../cern/colt/Partitioning.html#partition(cern.colt.list.tdouble.DoubleArrayList, int, int, cern.colt.list.tdouble.DoubleArrayList, cern.colt.list.tint.IntArrayList)">partition</a></strong>(<a href="../../cern/colt/list/tdouble/DoubleArrayList.html" title="class in cern.colt.list.tdouble">DoubleArrayList</a>&nbsp;list,
         int&nbsp;from,
         int&nbsp;to,
         <a href="../../cern/colt/list/tdouble/DoubleArrayList.html" title="class in cern.colt.list.tdouble">DoubleArrayList</a>&nbsp;splitters,
         <a href="../../cern/colt/list/tint/IntArrayList.html" title="class in cern.colt.list.tint">IntArrayList</a>&nbsp;splitIndexes)</code>
<div class="block">Equivalent to
 <tt>partition(list.elements(), from, to, splitters.elements(), 0, splitters.size()-1, splitIndexes.elements())</tt>
 .</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int)">partition</a></strong>(int[]&nbsp;list,
         int&nbsp;from,
         int&nbsp;to,
         int&nbsp;splitter)</code>
<div class="block">Partitions (partially sorts) the given list such that all elements
 falling into the given interval are placed next to each other.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int[], int, int, int[])">partition</a></strong>(int[]&nbsp;list,
         int&nbsp;from,
         int&nbsp;to,
         int[]&nbsp;splitters,
         int&nbsp;splitFrom,
         int&nbsp;splitTo,
         int[]&nbsp;splitIndexes)</code>
<div class="block">Partitions (partially sorts) the given list such that all elements
 falling into some intervals are placed next to each other.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../cern/colt/Partitioning.html#partition(cern.colt.list.tint.IntArrayList, int, int, cern.colt.list.tint.IntArrayList, cern.colt.list.tint.IntArrayList)">partition</a></strong>(<a href="../../cern/colt/list/tint/IntArrayList.html" title="class in cern.colt.list.tint">IntArrayList</a>&nbsp;list,
         int&nbsp;from,
         int&nbsp;to,
         <a href="../../cern/colt/list/tint/IntArrayList.html" title="class in cern.colt.list.tint">IntArrayList</a>&nbsp;splitters,
         <a href="../../cern/colt/list/tint/IntArrayList.html" title="class in cern.colt.list.tint">IntArrayList</a>&nbsp;splitIndexes)</code>
<div class="block">Equivalent to
 <tt>partition(list.elements(), from, to, splitters.elements(), 0, splitters.size()-1, splitIndexes.elements())</tt>
 .</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../cern/colt/Partitioning.html#partition(java.lang.Object[], int, int, java.lang.Object[], int, int, int[], java.util.Comparator)">partition</a></strong>(<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>[]&nbsp;list,
         int&nbsp;from,
         int&nbsp;to,
         <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>[]&nbsp;splitters,
         int&nbsp;splitFrom,
         int&nbsp;splitTo,
         int[]&nbsp;splitIndexes,
         <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/Comparator.html?is-external=true" title="class or interface in java.util">Comparator</a>&nbsp;comp)</code>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int[], int, int, int[])"><code>partition(int[],int,int,int[],int,int,int[])</code></a> except that
 it partitions <tt>Object[]</tt> rather than <tt>int[]</tt> arrays.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../cern/colt/Partitioning.html#partition(java.lang.Object[], int, int, java.lang.Object, java.util.Comparator)">partition</a></strong>(<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>[]&nbsp;list,
         int&nbsp;from,
         int&nbsp;to,
         <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&nbsp;splitter,
         <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/Comparator.html?is-external=true" title="class or interface in java.util">Comparator</a>&nbsp;comp)</code>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int)"><code>partition(int[],int,int,int)</code></a> except that it
 <i>synchronously</i> partitions the objects of the given list by the
 order of the given comparator.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../cern/colt/Partitioning.html#triplePartition(double[], double[], double[], int, int, double)">triplePartition</a></strong>(double[]&nbsp;list,
               double[]&nbsp;secondary,
               double[]&nbsp;tertiary,
               int&nbsp;from,
               int&nbsp;to,
               double&nbsp;splitter)</code>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#triplePartition(int[], int[], int[], int, int, int)"><code>triplePartition(int[],int[],int[],int,int,int)</code></a> except
 that it <i>synchronously</i> partitions <tt>double[]</tt> rather than
 <tt>int[]</tt> arrays.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../cern/colt/Partitioning.html#triplePartition(double[], double[], double[], int, int, double[], int, int, int[])">triplePartition</a></strong>(double[]&nbsp;list,
               double[]&nbsp;secondary,
               double[]&nbsp;tertiary,
               int&nbsp;from,
               int&nbsp;to,
               double[]&nbsp;splitters,
               int&nbsp;splitFrom,
               int&nbsp;splitTo,
               int[]&nbsp;splitIndexes)</code>
<div class="block">Same as
 <a href="../../cern/colt/Partitioning.html#triplePartition(int[], int[], int[], int, int, int[], int, int, int[])"><code>triplePartition(int[],int[],int[],int,int,int[],int,int,int[])</code></a>
 except that it <i>synchronously</i> partitions <tt>double[]</tt> rather
 than <tt>int[]</tt> arrays.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../cern/colt/Partitioning.html#triplePartition(int[], int[], int[], int, int, int)">triplePartition</a></strong>(int[]&nbsp;list,
               int[]&nbsp;secondary,
               int[]&nbsp;tertiary,
               int&nbsp;from,
               int&nbsp;to,
               int&nbsp;splitter)</code>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int)"><code>partition(int[],int,int,int)</code></a> except that this method
 <i>synchronously</i> partitions three arrays at the same time; all three
 arrays are partially sorted according to the elements of the primary
 array.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../cern/colt/Partitioning.html#triplePartition(int[], int[], int[], int, int, int[], int, int, int[])">triplePartition</a></strong>(int[]&nbsp;list,
               int[]&nbsp;secondary,
               int[]&nbsp;tertiary,
               int&nbsp;from,
               int&nbsp;to,
               int[]&nbsp;splitters,
               int&nbsp;splitFrom,
               int&nbsp;splitTo,
               int[]&nbsp;splitIndexes)</code>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int[], int, int, int[])"><code>partition(int[],int,int,int[],int,int,int[])</code></a> except that
 this method <i>synchronously</i> partitions three arrays at the same
 time; all three arrays are partially sorted according to the elements of
 the primary array.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a></h3>
<code><a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html?is-external=true#equals(java.lang.Object)" title="class or interface in java.lang">equals</a>, <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html?is-external=true#getClass()" title="class or interface in java.lang">getClass</a>, <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html?is-external=true#hashCode()" title="class or interface in java.lang">hashCode</a>, <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html?is-external=true#notify()" title="class or interface in java.lang">notify</a>, <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html?is-external=true#notifyAll()" title="class or interface in java.lang">notifyAll</a>, <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html?is-external=true#toString()" title="class or interface in java.lang">toString</a>, <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html?is-external=true#wait()" title="class or interface in java.lang">wait</a>, <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html?is-external=true#wait(long)" title="class or interface in java.lang">wait</a>, <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html?is-external=true#wait(long, int)" title="class or interface in java.lang">wait</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="swappedElements">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>swappedElements</h4>
<pre>public static&nbsp;int swappedElements</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="dualPartition(double[], double[], int, int, double[], int, int, int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dualPartition</h4>
<pre>public static&nbsp;void&nbsp;dualPartition(double[]&nbsp;list,
                 double[]&nbsp;secondary,
                 int&nbsp;from,
                 int&nbsp;to,
                 double[]&nbsp;splitters,
                 int&nbsp;splitFrom,
                 int&nbsp;splitTo,
                 int[]&nbsp;splitIndexes)</pre>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#dualPartition(int[], int[], int, int, int[], int, int, int[])"><code>dualPartition(int[],int[],int,int,int[],int,int,int[])</code></a>
 except that it <i>synchronously</i> partitions <tt>double[]</tt> rather
 than <tt>int[]</tt> arrays.</div>
</li>
</ul>
<a name="dualPartition(double[], double[], int, int, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dualPartition</h4>
<pre>public static&nbsp;int&nbsp;dualPartition(double[]&nbsp;list,
                double[]&nbsp;secondary,
                int&nbsp;from,
                int&nbsp;to,
                double&nbsp;splitter)</pre>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#dualPartition(int[], int[], int, int, int)"><code>dualPartition(int[],int[],int,int,int)</code></a> except that it
 <i>synchronously</i> partitions <tt>double[]</tt> rather than
 <tt>int[]</tt> arrays.</div>
</li>
</ul>
<a name="dualPartition(int[], int[], int, int, int[], int, int, int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dualPartition</h4>
<pre>public static&nbsp;void&nbsp;dualPartition(int[]&nbsp;list,
                 int[]&nbsp;secondary,
                 int&nbsp;from,
                 int&nbsp;to,
                 int[]&nbsp;splitters,
                 int&nbsp;splitFrom,
                 int&nbsp;splitTo,
                 int[]&nbsp;splitIndexes)</pre>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int[], int, int, int[])"><code>partition(int[],int,int,int[],int,int,int[])</code></a> except that
 this method <i>synchronously</i> partitions two arrays at the same time;
 both arrays are partially sorted according to the elements of the primary
 array. In other words, each time an element in the primary array is moved
 from index A to B, the correspoding element within the secondary array is
 also moved from index A to B.
 <p>
 <b>Use cases:</b>
 <p>
 Image having a large list of 2-dimensional points. If memory consumption
 and performance matter, it is a good idea to physically lay them out as
 two 1-dimensional arrays (using something like <tt>Point2D</tt> objects
 would be prohibitively expensive, both in terms of time and space). Now
 imagine wanting to histogram the points. We may want to partially sort
 the points by x-coordinate into intervals. This method efficiently does
 the job.
 <p>
 <b>Performance:</b>
 <p>
 Same as for single-partition methods.</div>
</li>
</ul>
<a name="dualPartition(int[], int[], int, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dualPartition</h4>
<pre>public static&nbsp;int&nbsp;dualPartition(int[]&nbsp;list,
                int[]&nbsp;secondary,
                int&nbsp;from,
                int&nbsp;to,
                int&nbsp;splitter)</pre>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int)"><code>partition(int[],int,int,int)</code></a> except that this method
 <i>synchronously</i> partitions two arrays at the same time; both arrays
 are partially sorted according to the elements of the primary array. In
 other words, each time an element in the primary array is moved from
 index A to B, the correspoding element within the secondary array is also
 moved from index A to B.
 <p>
 <b>Performance:</b>
 <p>
 Same as for single-partition methods.</div>
</li>
</ul>
<a name="genericPartition(int, int, int, int, int[], cern.colt.function.tint.IntComparator, cern.colt.function.tint.IntComparator, cern.colt.function.tint.IntComparator, cern.colt.Swapper)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>genericPartition</h4>
<pre>public static&nbsp;void&nbsp;genericPartition(int&nbsp;from,
                    int&nbsp;to,
                    int&nbsp;splitFrom,
                    int&nbsp;splitTo,
                    int[]&nbsp;splitIndexes,
                    <a href="../../cern/colt/function/tint/IntComparator.html" title="interface in cern.colt.function.tint">IntComparator</a>&nbsp;comp,
                    <a href="../../cern/colt/function/tint/IntComparator.html" title="interface in cern.colt.function.tint">IntComparator</a>&nbsp;comp2,
                    <a href="../../cern/colt/function/tint/IntComparator.html" title="interface in cern.colt.function.tint">IntComparator</a>&nbsp;comp3,
                    <a href="../../cern/colt/Swapper.html" title="interface in cern.colt">Swapper</a>&nbsp;swapper)</pre>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int[], int, int, int[])"><code>partition(int[],int,int,int[],int,int,int[])</code></a> except that
 it <i>generically</i> partitions arbitrary shaped data (for example
 matrices or multiple arrays) rather than <tt>int[]</tt> arrays.
 <p>
 This method operates on arbitrary shaped data and arbitrary shaped
 splitters. In fact, it has no idea what kind of data by what kind of
 splitters it is partitioning. Comparisons and swapping are delegated to
 user provided objects which know their data and can do the job.
 <p>
 Lets call the generic data <tt>g</tt> (it may be a matrix, one array,
 three linked lists or whatever). Lets call the generic splitters
 <tt>s</tt>. This class takes a user comparison function operating on two
 indexes <tt>(a,b)</tt>, namely an <a href="../../cern/colt/function/tint/IntComparator.html" title="interface in cern.colt.function.tint"><code>IntComparator</code></a>. The comparison
 function determines whether <tt>s[a]</tt> is equal, less or greater than
 <tt>g[b]</tt>. This method can then decide to swap the data <tt>g[b]</tt>
 with the data <tt>g[c]</tt> (yes, <tt>c</tt>, not <tt>a</tt>). It calls a
 user provided <a href="../../cern/colt/Swapper.html" title="interface in cern.colt"><code>Swapper</code></a> object that knows how to swap the
 data of these two indexes.
 <p>
 Again, note the details: Comparisons compare <tt>s[a]</tt> with
 <tt>g[b]</tt>. Swaps swap <tt>g[b]</tt> with <tt>g[c]</tt>. Prior to
 calling this method, the generic splitters <tt>s</tt> must be sorted
 ascending and must not contain multiple equal values. These preconditions
 are not checked; be sure that they are met.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>from</code> - the index of the first element within <tt>g</tt> to be
            considered.</dd><dd><code>to</code> - the index of the last element within <tt>g</tt> to be
            considered. The method considers the elements
            <tt>g[from] .. g[to]</tt>.</dd><dd><code>splitFrom</code> - the index of the first splitter element to be considered.</dd><dd><code>splitTo</code> - the index of the last splitter element to be considered. The
            method considers the splitter elements
            <tt>s[splitFrom] .. s[splitTo]</tt>.</dd><dd><code>splitIndexes</code> - a list into which this method fills the indexes of elements
            delimiting intervals. Upon return
            <tt>splitIndexes[splitFrom..splitTo]</tt> will be set
            accordingly. Therefore, must satisfy
            <tt>splitIndexes.length > splitTo</tt>.</dd><dd><code>comp</code> - the comparator comparing a splitter with an element of the
            generic data. Takes as first argument the index <tt>a</tt>
            within the generic splitters <tt>s</tt>. Takes as second
            argument the index <tt>b</tt> within the generic data
            <tt>g</tt>.</dd><dd><code>comp2</code> - the comparator to determine the order of the generic data.
            Takes as first argument the index <tt>a</tt> within the
            generic data <tt>g</tt>. Takes as second argument the index
            <tt>b</tt> within the generic data <tt>g</tt>.</dd><dd><code>comp3</code> - the comparator comparing a splitter with another splitter.
            Takes as first argument the index <tt>a</tt> within the
            generic splitters <tt>s</tt>. Takes as second argument the
            index <tt>b</tt> within the generic splitters <tt>g</tt>.</dd><dd><code>swapper</code> - an object that knows how to swap the elements at any two
            indexes (a,b). Takes as first argument the index <tt>b</tt>
            within the generic data <tt>g</tt>. Takes as second argument
            the index <tt>c</tt> within the generic data <tt>g</tt>.
 
            <p>
            Tip: Normally you will have
            <tt>splitIndexes.length == s.length</tt> as well as
            <tt>from==0, to==g.length-1</tt> and
            <tt>splitFrom==0, splitTo==s.length-1</tt>.</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../cern/colt/Sorting.html#binarySearchFromTo(int, int, cern.colt.function.tint.IntComparator)"><code>Sorting.binarySearchFromTo(int,int,IntComparator)</code></a></dd></dl>
</li>
</ul>
<a name="partition(double[], int, int, double[], int, int, int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>partition</h4>
<pre>public static&nbsp;void&nbsp;partition(double[]&nbsp;list,
             int&nbsp;from,
             int&nbsp;to,
             double[]&nbsp;splitters,
             int&nbsp;splitFrom,
             int&nbsp;splitTo,
             int[]&nbsp;splitIndexes)</pre>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int[], int, int, int[])"><code>partition(int[],int,int,int[],int,int,int[])</code></a> except that
 it partitions <tt>double[]</tt> rather than <tt>int[]</tt> arrays.</div>
</li>
</ul>
<a name="partition(double[], int, int, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>partition</h4>
<pre>public static&nbsp;int&nbsp;partition(double[]&nbsp;list,
            int&nbsp;from,
            int&nbsp;to,
            double&nbsp;splitter)</pre>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int)"><code>partition(int[],int,int,int)</code></a> except that it partitions
 <tt>double[]</tt> rather than <tt>int[]</tt> arrays.</div>
</li>
</ul>
<a name="partition(int[], int, int, int[], int, int, int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>partition</h4>
<pre>public static&nbsp;void&nbsp;partition(int[]&nbsp;list,
             int&nbsp;from,
             int&nbsp;to,
             int[]&nbsp;splitters,
             int&nbsp;splitFrom,
             int&nbsp;splitTo,
             int[]&nbsp;splitIndexes)</pre>
<div class="block">Partitions (partially sorts) the given list such that all elements
 falling into some intervals are placed next to each other. Returns the
 indexes of elements delimiting intervals.
 <p>
 <b>Example:</b>
 <p>
 <tt>list = (7, 4, 5, 50, 6, 4, 3, 6), splitters = (5, 10, 30)</tt>
 defines the three intervals <tt>[-infinity,5), [5,10), [10,30)</tt>. Lets
 define to sort the entire list (<tt>from=0, to=7</tt>) using all
 splitters (<tt>splitFrom==0, splitTo=2</tt>).
 <p>
 The method modifies the list to be
 <tt>list = (4, 4, 3, 6, 7, 5, 6, 50)</tt> and returns the
 <tt>splitIndexes = (2, 6, 6)</tt>. In other words,
 <ul>
 <li>All values <tt>list[0..2]</tt> fall into <tt>[-infinity,5)</tt>.
 <li>All values <tt>list[3..6]</tt> fall into <tt>[5,10)</tt>.
 <li>All values <tt>list[7..6]</tt> fall into <tt>[10,30)</tt>, i.e. no
 elements, since <tt>7>6</tt>.
 <li>All values <tt>list[7 .. 7=list.length-1]</tt> fall into
 <tt>[30,infinity]</tt>.
 <li>In general, all values
 <tt>list[splitIndexes[j-1]+1 .. splitIndexes[j]]</tt> fall into interval
 <tt>j</tt>.
 </ul>
 As can be seen, the list is partially sorted such that values falling
 into a certain interval are placed next to each other. Note that
 <i>within</i> an interval, elements are entirelly unsorted. They are only
 sorted across interval boundaries. In particular, this partitioning
 algorithm is not <i>stable</i>: the relative order of elements is not
 preserved (Producing a stable algorithm would require no more than minor
 modifications to method partition(int[],int,int,int)).
 <p>
 More formally, this method guarantees that upon return
 <tt>for all j = splitFrom .. splitTo</tt> there holds: <br>
 <tt>for all i = splitIndexes[j-1]+1 .. splitIndexes[j]: splitters[j-1] <= list[i] < splitters[j]</tt>.
 <p>
 <b>Performance:</b>
 <p>
 Let <tt>N=to-from+1</tt> be the number of elements to be partitioned. Let
 <tt>k=splitTo-splitFrom+1</tt> be the number of splitter elements. Then
 we have the following time complexities
 <ul>
 <li>Worst case: <tt>O( N * log(k) )</tt>.
 <li>Average case: <tt>O( N * log(k) )</tt>.
 <li>Best case: <tt>O( N )</tt>. In general, the more uniform (skewed) the
 data is spread across intervals, the more performance approaches the
 worst (best) case. If no elements fall into the given intervals, running
 time is linear.
 </ul>
 No temporary memory is allocated; the sort is in-place.
 <p>
 <b>Implementation:</b>
 <p>
 The algorithm can be seen as a Bentley/McIlroy quicksort where swapping
 and insertion sort are omitted. It is designed to detect and take
 advantage of skew while maintaining good performance in the uniform case.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>list</code> - the list to be partially sorted.</dd><dd><code>from</code> - the index of the first element within <tt>list</tt> to be
            considered.</dd><dd><code>to</code> - the index of the last element within <tt>list</tt> to be
            considered. The method considers the elements
            <tt>list[from] .. list[to]</tt>.</dd><dd><code>splitters</code> - the values at which the list shall be split into intervals.
            Must be sorted ascending and must not contain multiple
            identical values. These preconditions are not checked; be sure
            that they are met.</dd><dd><code>splitFrom</code> - the index of the first splitter element to be considered.</dd><dd><code>splitTo</code> - the index of the last splitter element to be considered. The
            method considers the splitter elements
            <tt>splitters[splitFrom] .. splitters[splitTo]</tt>.</dd><dd><code>splitIndexes</code> - a list into which this method fills the indexes of elements
            delimiting intervals. Upon return
            <tt>splitIndexes[splitFrom..splitTo]</tt> will be set
            accordingly. Therefore, must satisfy
            <tt>splitIndexes.length > splitTo</tt>.
            <p>
            Tip: Normally you will have
            <tt>splitIndexes.length == splitters.length</tt> as well as
            <tt>from==0, to==list.length-1</tt> and
            <tt>splitFrom==0, splitTo==splitters.length-1</tt>.</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../cern/colt/Arrays.html" title="class in cern.colt"><code>Arrays</code></a>, 
<a href="../../cern/colt/GenericSorting.html" title="class in cern.colt"><code>GenericSorting</code></a>, 
<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/Arrays.html?is-external=true" title="class or interface in java.util"><code>Arrays</code></a></dd></dl>
</li>
</ul>
<a name="partition(int[], int, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>partition</h4>
<pre>public static&nbsp;int&nbsp;partition(int[]&nbsp;list,
            int&nbsp;from,
            int&nbsp;to,
            int&nbsp;splitter)</pre>
<div class="block">Partitions (partially sorts) the given list such that all elements
 falling into the given interval are placed next to each other. Returns
 the index of the element delimiting the interval.
 <p>
 <b>Example:</b>
 <p>
 <tt>list = (7, 4, 5, 50, 6, 4, 3, 6), splitter = 5</tt> defines the two
 intervals <tt>[-infinity,5), [5,+infinity]</tt>.
 <p>
 The method modifies the list to be
 <tt>list = (4, 4, 3, 50, 6, 7, 5, 6)</tt> and returns the split index
 <tt>2</tt>. In other words,
 <ul>
 <li>All values <tt>list[0..2]</tt> fall into <tt>[-infinity,5)</tt>.
 <li>All values <tt>list[3=2+1 .. 7=list.length-1]</tt> fall into
 <tt>[5,+infinity]</tt>.
 </ul>
 As can be seen, the list is partially sorted such that values falling
 into a certain interval are placed next to each other. Note that
 <i>within</i> an interval, elements are entirelly unsorted. They are only
 sorted across interval boundaries. In particular, this partitioning
 algorithm is not <i>stable</i>.
 <p>
 More formally, this method guarantees that upon return there holds:
 <ul>
 <li>for all <tt>i = from .. returnValue: list[i] < splitter</tt> and
 <li>for all
 <tt>i = returnValue+1 .. list.length-1: !(list[i] < splitter)</tt>.
 </ul>
 <p>
 <b>Performance:</b>
 <p>
 Let <tt>N=to-from+1</tt> be the number of elements to be partially
 sorted. Then the time complexity is <tt>O( N )</tt>. No temporary memory
 is allocated; the sort is in-place.
 
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>list</code> - the list to be partially sorted.</dd><dd><code>from</code> - the index of the first element within <tt>list</tt> to be
            considered.</dd><dd><code>to</code> - the index of the last element within <tt>list</tt> to be
            considered. The method considers the elements
            <tt>list[from] .. list[to]</tt>.</dd><dd><code>splitter</code> - the value at which the list shall be split.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the index of the largest element falling into the interval
         <tt>[-infinity,splitter)</tt>, as seen after partitioning.</dd></dl>
</li>
</ul>
<a name="partition(java.lang.Object[], int, int, java.lang.Object[], int, int, int[], java.util.Comparator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>partition</h4>
<pre>public static&nbsp;void&nbsp;partition(<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>[]&nbsp;list,
             int&nbsp;from,
             int&nbsp;to,
             <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>[]&nbsp;splitters,
             int&nbsp;splitFrom,
             int&nbsp;splitTo,
             int[]&nbsp;splitIndexes,
             <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/Comparator.html?is-external=true" title="class or interface in java.util">Comparator</a>&nbsp;comp)</pre>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int[], int, int, int[])"><code>partition(int[],int,int,int[],int,int,int[])</code></a> except that
 it partitions <tt>Object[]</tt> rather than <tt>int[]</tt> arrays.</div>
</li>
</ul>
<a name="partition(java.lang.Object[], int, int, java.lang.Object, java.util.Comparator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>partition</h4>
<pre>public static&nbsp;int&nbsp;partition(<a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>[]&nbsp;list,
            int&nbsp;from,
            int&nbsp;to,
            <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&nbsp;splitter,
            <a href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/Comparator.html?is-external=true" title="class or interface in java.util">Comparator</a>&nbsp;comp)</pre>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int)"><code>partition(int[],int,int,int)</code></a> except that it
 <i>synchronously</i> partitions the objects of the given list by the
 order of the given comparator.</div>
</li>
</ul>
<a name="partition(cern.colt.list.tdouble.DoubleArrayList, int, int, cern.colt.list.tdouble.DoubleArrayList, cern.colt.list.tint.IntArrayList)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>partition</h4>
<pre>public static&nbsp;void&nbsp;partition(<a href="../../cern/colt/list/tdouble/DoubleArrayList.html" title="class in cern.colt.list.tdouble">DoubleArrayList</a>&nbsp;list,
             int&nbsp;from,
             int&nbsp;to,
             <a href="../../cern/colt/list/tdouble/DoubleArrayList.html" title="class in cern.colt.list.tdouble">DoubleArrayList</a>&nbsp;splitters,
             <a href="../../cern/colt/list/tint/IntArrayList.html" title="class in cern.colt.list.tint">IntArrayList</a>&nbsp;splitIndexes)</pre>
<div class="block">Equivalent to
 <tt>partition(list.elements(), from, to, splitters.elements(), 0, splitters.size()-1, splitIndexes.elements())</tt>
 .</div>
</li>
</ul>
<a name="partition(cern.colt.list.tint.IntArrayList, int, int, cern.colt.list.tint.IntArrayList, cern.colt.list.tint.IntArrayList)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>partition</h4>
<pre>public static&nbsp;void&nbsp;partition(<a href="../../cern/colt/list/tint/IntArrayList.html" title="class in cern.colt.list.tint">IntArrayList</a>&nbsp;list,
             int&nbsp;from,
             int&nbsp;to,
             <a href="../../cern/colt/list/tint/IntArrayList.html" title="class in cern.colt.list.tint">IntArrayList</a>&nbsp;splitters,
             <a href="../../cern/colt/list/tint/IntArrayList.html" title="class in cern.colt.list.tint">IntArrayList</a>&nbsp;splitIndexes)</pre>
<div class="block">Equivalent to
 <tt>partition(list.elements(), from, to, splitters.elements(), 0, splitters.size()-1, splitIndexes.elements())</tt>
 .</div>
</li>
</ul>
<a name="triplePartition(double[], double[], double[], int, int, double[], int, int, int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>triplePartition</h4>
<pre>public static&nbsp;void&nbsp;triplePartition(double[]&nbsp;list,
                   double[]&nbsp;secondary,
                   double[]&nbsp;tertiary,
                   int&nbsp;from,
                   int&nbsp;to,
                   double[]&nbsp;splitters,
                   int&nbsp;splitFrom,
                   int&nbsp;splitTo,
                   int[]&nbsp;splitIndexes)</pre>
<div class="block">Same as
 <a href="../../cern/colt/Partitioning.html#triplePartition(int[], int[], int[], int, int, int[], int, int, int[])"><code>triplePartition(int[],int[],int[],int,int,int[],int,int,int[])</code></a>
 except that it <i>synchronously</i> partitions <tt>double[]</tt> rather
 than <tt>int[]</tt> arrays.</div>
</li>
</ul>
<a name="triplePartition(double[], double[], double[], int, int, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>triplePartition</h4>
<pre>public static&nbsp;int&nbsp;triplePartition(double[]&nbsp;list,
                  double[]&nbsp;secondary,
                  double[]&nbsp;tertiary,
                  int&nbsp;from,
                  int&nbsp;to,
                  double&nbsp;splitter)</pre>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#triplePartition(int[], int[], int[], int, int, int)"><code>triplePartition(int[],int[],int[],int,int,int)</code></a> except
 that it <i>synchronously</i> partitions <tt>double[]</tt> rather than
 <tt>int[]</tt> arrays.</div>
</li>
</ul>
<a name="triplePartition(int[], int[], int[], int, int, int[], int, int, int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>triplePartition</h4>
<pre>public static&nbsp;void&nbsp;triplePartition(int[]&nbsp;list,
                   int[]&nbsp;secondary,
                   int[]&nbsp;tertiary,
                   int&nbsp;from,
                   int&nbsp;to,
                   int[]&nbsp;splitters,
                   int&nbsp;splitFrom,
                   int&nbsp;splitTo,
                   int[]&nbsp;splitIndexes)</pre>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int[], int, int, int[])"><code>partition(int[],int,int,int[],int,int,int[])</code></a> except that
 this method <i>synchronously</i> partitions three arrays at the same
 time; all three arrays are partially sorted according to the elements of
 the primary array. In other words, each time an element in the primary
 array is moved from index A to B, the correspoding element within the
 secondary array as well as the corresponding element within the tertiary
 array are also moved from index A to B.
 <p>
 <b>Use cases:</b>
 <p>
 Image having a large list of 3-dimensional points. If memory consumption
 and performance matter, it is a good idea to physically lay them out as
 three 1-dimensional arrays (using something like <tt>Point3D</tt> objects
 would be prohibitively expensive, both in terms of time and space). Now
 imagine wanting to histogram the points. We may want to partially sort
 the points by x-coordinate into intervals. This method efficiently does
 the job.
 <p>
 <b>Performance:</b>
 <p>
 Same as for single-partition methods.</div>
</li>
</ul>
<a name="triplePartition(int[], int[], int[], int, int, int)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>triplePartition</h4>
<pre>public static&nbsp;int&nbsp;triplePartition(int[]&nbsp;list,
                  int[]&nbsp;secondary,
                  int[]&nbsp;tertiary,
                  int&nbsp;from,
                  int&nbsp;to,
                  int&nbsp;splitter)</pre>
<div class="block">Same as <a href="../../cern/colt/Partitioning.html#partition(int[], int, int, int)"><code>partition(int[],int,int,int)</code></a> except that this method
 <i>synchronously</i> partitions three arrays at the same time; all three
 arrays are partially sorted according to the elements of the primary
 array. In other words, each time an element in the primary array is moved
 from index A to B, the correspoding element within the secondary array as
 well as the corresponding element within the tertiary array are also
 moved from index A to B.
 <p>
 <b>Performance:</b>
 <p>
 Same as for single-partition methods.</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Partitioning.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><em><b>Parallel Colt 0.10.1</b></em></div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../cern/colt/ParallelQuickSort.html" title="class in cern.colt"><span class="strong">Prev Class</span></a></li>
<li><a href="../../cern/colt/PersistentObject.html" title="class in cern.colt"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?cern/colt/Partitioning.html" target="_top">Frames</a></li>
<li><a href="Partitioning.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small><font size=-1 >Jump to the <a target=_top href=http://sourceforge.net/projects/parallelcolt/ >Parallel Colt Homepage</a></small></p>
</body>
</html>
